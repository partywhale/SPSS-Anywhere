scopeName: 'source.spss'
name: 'SPSS'
fileTypes: [ 'sps' ]
limitLineLength: false
firstLineMatch: '^(?:\\* Encoding: UTF-8)'
patterns: [
  { include: '#metaMultilineComments' }
  { include: '#metaCommandFriendlyComments' }
  { include: '#metaQuoteStrings' }
  { include: '#metaCommands' }
  { include: '#metaConditionals' }
  {
    name: 'keyword.keyword.spss'
    match: '\\b(?i:(BIPLOT|CENTR|DENOMINATOR|LOADING|NUMERATOR))\\b'
  }
  { include: '#metaOperators' }
  { include: '#metaConstants' }
  { include: '#metaPunctuation' }
]

repository:
  # Meta groups, referenced in main patterns[]
  metaMultilineComments: {
    comment: 'These are the multiline comment types. They cannot go inside a command.'
    patterns: [
      { include: '#multilineCommentAsterisk' }
      { include: '#multilineCommentCommand' }
    ]
  }
  metaCommandFriendlyComments: {
    comment: 'These comment types can be used within a command. Comments on their own line inside a command cause an error (blank line as terminator).'
    patterns: [
      { include: '#inlineComment' }
      { include: '#lineComment' }
    ]
  }
  metaQuoteStrings: {
    comment: 'Includes both single and double quote strings. SPSS does not support other string types.'
    patterns: [
      { include: '#singleQuoteString' }
      { include: '#doubleQuoteString' }
    ]
  }
  metaConditionals: {
    comment: 'Includes all conditionals for flow control (e.g. if, else).'
    patterns: [
      { include: '#controlConditionals' }
    ]
  }
  metaOperators: {
    comment: 'Includes all operators, in written form (e.g. EQ) or symbolic (e.g. =).'
    patterns: [
      { include: '#operatorsNumeric' }
      { include: '#operatorsLogical' }
      { include: '#operatorsLogicalSymbolic' }
      { include: '#operatorsRelational' }
      { include: '#operatorsRelationalSymbolic' }
      { include: '#operatorsArithmetic' }
    ]
  }
  metaConstants: {
    comment: 'Includes constants provided by SPSS.'
    patterns: [
      { include: '#plainLanguageConstants' }
    ]
  }
  metaPunctuation: {
    comment: 'Includes punctuation, i.e. brackets.'
    patterns: [
      { include: '#punctuationForArray' }
      { include: '#punctuationForFunction' }
    ]
  }
  metaCommands: {
    comment: 'Includes commands provided by SPSS.'
    patterns: [
      { include: '#simpleCommands' }
      { include: '#twoStageLeastSquares' }
      { include: '#autocorrelationFunction' }
      { include: '#addFiles' }
      { include: '#automatedDataPreparation' }
      { include: '#aggregateCommand' }
      { include: '#aimCommand' }
      { include: '#alscalCommand' }
      { include: '#alterType' }
      { include: '#anacorCommand' }
      { include: '#analysisOfVariance' }
      { include: '#applyDictionary' }
      { include: '#aregCommand' }
      { include: '#arimaCommand' }
      { include: '#autoRecode' }
      { include: '#bayesANOVA' }
      { include: '#bayesCorrelation' }
      { include: '#bayesIndependent' }
      { include: '#bayesLogLinear' }
      { include: '#bayesOneSample' }
      { include: '#bayesRegression' }
      { include: '#bayesRelated' }
      { include: '#bayesRepeated' }
      { include: '#beginData' }
      { include: '#beginExpr' }
      { include: '#simprepBegin' }
      { include: '#beginGPL' }
      { include: '#beginProgram' }
      { include: '#bootStrap' }
      { include: '#casePlot' }
      { include: '#casesToVars' }
      { include: '#catpcaCommand' }
      { include: '#catregCommand' }
      { include: '#ccfCommand' }
      { include: '#clusterCommand' }
      { include: '#codeBook' }
      { include: '#compareDatasets' }
      { include: '#conjointCommand' }
      { include: '#correlationsCommand' }
      { include: '#correspondenceCommand' }
      { include: '#coxregCommand' }
      { include: '#createCommand' }
      { include: '#crossTabulation' }
      { include: '#csCoxReg' }
      { include: '#csDescriptives' }
      { include: '#csGLM' }
      { include: '#csLogistic' }
      { include: '#csOrdinal' }
      { include: '#csPlan' }
      { include: '#csSelect' }
      { include: '#csTabulate' }
      { include: '#customTables' }
      { include: '#curveFit' }
      { include: '#dataList' }
      { include: '#datafileAttribute' }
      { include: '#datasetActivate' }
      { include: '#datasetCopy' }
      { include: '#datasetDeclare' }
      { include: '#datasetName' }
      { include: '#dateCommand' }
      { include: '#defineEndDefine' }
      { include: '#descriptivesCommand' }
      { include: '#detectAnomaly' }
      { include: '#discriminantCommand' }
      { include: '#displayCommand' }
      { include: '#eraseCommand' }
      { include: '#examineCommand' }
      { include: '#exportCommand' }
      { include: '#exSmooth' }
      { include: '#extensionCommand' }
      { include: '#factorCommand' }
      { include: '#fileHandle' }
      { include: '#fileType' }
      { include: '#filterCommand' }
      { include: '#fitCommand' }
      { include: '#fleissMultiraterKappa' }
      { include: '#flipCommand' }
      { include: '#frequenciesCommand' }
      { include: '#generalizedLinear' }
      { include: '#generalizedLinearMixed' }
      { include: '#generalizedLog' }
      { include: '#getCommand' }
      { include: '#getCapture' }
      { include: '#getData' }
      { include: '#getSAS' }
      { include: '#getStata' }
      { include: '#getTranslate' }
      { include: '#getCognos' }
      { include: '#getTM1' }
      { include: '#ggraphCommand' }
      { include: '#generalLinearModel' }
      { include: '#graphCommand' }
      { include: '#hierarchicalLogLinear' }
      { include: '#homalsCommand' }
      { include: '#hostCommand' }
      { include: '#iGraphCommand' }
      { include: '#importCommand' }
    ]
  }

  # Meta groups for command formatting:
  metaCommandFormatting: {
    comment: 'Everything that is formated in a command block, except the command word itself, subcommands, and command/subcom-specific keywords.'
    patterns: [
      { include: '#metaCommandFriendlyComments' }
      { include: '#metaQuoteStrings' }
      { include: '#metaConditionals' }
      { include: '#metaOperators' }
      { include: '#metaConstants' }
      { include: '#metaPunctuation' }
      { include: '#commandBodyText' }
    ]
  }

  # Comments
  multilineCommentAsterisk: {
    comment: 'Identify multi-line comments beginning with an asterisk and ending with a period'
    name: 'comment.block.asterisk.spss'
    begin: '(^\\*)'
    beginCaptures:
      1: name: 'punctuation.definition.comment.spss'
    end: '(\\.\\s*$)'
    endCaptures:
      0: name: 'punctuation.definition.comment.spss'
  }
  multilineCommentCommand: {
    name: 'comment.block.comment.spss'
    begin: '^(?i:COMMENT)'
    beginCaptures:
      1: name: 'punctuation.definition.comment.spss'
    end: '(\\.\\s*$)'
    endCaptures:
      0: name: 'punctuation.definition.comment.spss'
  }
  inlineComment: {
    comment: 'Identify inline comments beginning with `/*` and ending with `*/`'
    name: 'comment.line.spss'
    match: '(\\/\\*)(.*)(\\*\\/)'
  }
  lineComment: {
    comment: 'Identify single-line comments beginning with `/*`'
    name: 'comment.line.spss'
    match: '\\/\\*.*$'
  }

  # Quote strings:
  singleQuoteString: {
    name: 'string.quoted.single.spss'
    begin: '\''
    end: '\''
  }
  doubleQuoteString: {
    name: 'string.quoted.double.spss'
    begin: '"'
    end: '"'
  }

  # Global keywords & operators:
  controlConditionals: {
    name: 'keyword.control.conditionals.spss'
    match: '\\b(?i:(IF|THEN|ELSE|WHILE|FOR|DO|END|REPEAT|BY|WITH|ALL|TO|BREAK|VS|AT))\\b'
  }
  operatorsNumeric: {
    name: 'keyword.operator.numeric.spss'
    match: '\\b(?i:(LOWEST|LO|HIGHEST|HI|THRU|MISSING|SYSMIS))\\b'
  }
  operatorsLogical: {
    name: 'keyword.operator.logical.spss'
    match: '\\b(?i:(AND|OR|NOT))\\b'
  }
  operatorsLogicalSymbolic: {
    name: 'keyword.operator.logical.symbolic.spss'
    match: '\\&|\\|'
  }
  operatorsRelational: {
    name: 'keyword.operator.relational.spss'
    match: '\\b(?i:(EQ|NE|LT|LE|GT|GE))\\b'
  }
  operatorsRelationalSymbolic: {
    name: 'keyword.operator.relational.symbolic.spss'
    match: '=|<>|<|>|<=|>=|~=|Â¬='
  }
  operatorsArithmetic: {
    name: 'keyword.operator.arithmetic.spss'
    match: '\\+|\\-|\\*|/|\\*\\*'
  }

  # Constants:
  plainLanguageConstants: {
    name: 'constant.language.spss'
    match: '\\b(?i:(true|false|null))\\b'
  }

  # Bracket punctuation:
  punctuationForArray: {
    name: 'punctuation.section.array.spss'
    match: '\\[|\\]'
  }
  punctuationForFunction: {
    name: 'punctuation.section.function.spss'
    match: '\\(|\\)'
  }

  # Command body text:
  commandBodyText: {
    comment: 'The command takes up the whole code block, but we only want the command keyword and period to highlight. Also only highlight relevant subcommands and other scopes.'
    name: 'punctuation.command.body.spss'
    match: '((\\$*)(\\#*)(\\@*)\\b([0-9._\\p{L}]+)\\b)|([\\?!@#$%^\\.,;:\\\\{}`~])'
  }

  # Commands:
  simpleCommands: {
    comment: 'Commands with no subcommands or special keywords.'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADD DOCUMENT|ADD VALUE LABELS|CACHE|CD|CLEAR TIME PROGRAM
      |CLEAR TRANSFORMATIONS|COMPUTE|COUNT|DATASET CLOSE|DATASET DISPLAY|DELETE VARIABLES
      |DOCUMENT|DROP DOCUMENTS|ECHO|END CASE|END FILE|EXECUTE|FILE LABEL|FINISH|FORMATS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  twoStageLeastSquares: {
    comment: '2SLS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(2SLS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to 2SLS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(EQUATION|INSTRUMENTS|ENDOGENOUS))\\b'
      }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomSave' }
      { include: '#subcomPrint' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for 2SLS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PRED|RESSID|COV))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  autocorrelationFunction: {
    comment: 'ACF Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ACF))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ACF.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SERROR|PACF))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomSeasonal' }
      { include: '#subcomMXAuto' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for ACF.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(IND|MA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  addFiles: {
    comment: 'ADD FILES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADD FILES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomRename' }
      { include: '#subcomDrop' }
      { include: '#subcomKeep' }
      { include: '#subcomIn' }
      { include: '#subcomFirst' }
      { include: '#subcomLast' }
      { include: '#subcomMap' }
      {
        comment: 'Valid keywords for ADD FILES.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  automatedDataPreparation: {
    comment: 'ADP Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADP))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ADP.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PREPDATETIME|ADJUSTLEVEL|OUTLIERHANDLING|REPLACEMISSING|REORDERNOMINAL))\\b'
      }
      { include: '#subcomFields' }
      { include: '#subcomScreening' }
      { include: '#subcomRescale' }
      { include: '#subcomTransform' }
      { include: '#subcomCriteria' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for ADP.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(TARGET|INPUT|ANALYSISWEIGHT|(DATE|TIME)DURATION
          |EXTRACT(YEAR|MONTH|DAY|HOUR|MINUTE|SECOND)|SUFFIX|PCTMISSING|(UNIQUE|SINGLE)CAT
          |MAXVALORDINAL|MINVALCONTINUOUS|CUTOFF|REPLACEWITH|MERGESUPERVISED|MERGEUNSUPERVISED
          |BINNING|SELECTION|CONSTRUCTION))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aggregateCommand: {
    comment: 'AGGREGATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AGGREGATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AGGREGATE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(DOCUMENT|PRESORTED))\\b'
      }
      { include: '#subcomOutfile' }
      { include: '#subcomMissing' }
      { include: '#subcomSum' }
      { include: '#subcomMean' }
      { include: '#subcomMedian' }
      { include: '#subcomStandardDeviation' }
      { include: '#subcomMax' }
      { include: '#subcomMin' }
      { include: '#subcomPGT' }
      { include: '#subcomPLT' }
      { include: '#subcomPIN' }
      { include: '#subcomPOUT' }
      { include: '#subcomFGT' }
      { include: '#subcomFLT' }
      { include: '#subcomFIN' }
      { include: '#subcomFOUT' }
      { include: '#subcomN' }
      { include: '#subcomNU' }
      { include: '#subcomNMiss' }
      { include: '#subcomNUMiss' }
      { include: '#subcomFirst' }
      { include: '#subcomLast' }
      {
        comment: 'Valid keywords for AGGREGATE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(MODE|OVERWRITE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aimCommand: {
    comment: 'AIM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AIM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCategorical' }
      { include: '#subcomContinuous' }
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for AIM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ADJUST|CI|HIDENOTSIG|SHOWREFLINE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  alscalCommand: {
    comment: 'ALSCAL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ALSCAL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ALSCAL.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(LEVEL))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomInput' }
      { include: '#subcomShape' }
      { include: '#subcomCondition' }
      { include: '#subcomFile' }
      { include: '#subcomModel' }
      { include: '#subcomCriteria' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomOutfile' }
      { include: '#subcomMatrix' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  alterType: {
    comment: 'ALTER TYPE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ALTER TYPE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPrint' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  anacorCommand: {
    comment: 'ANACOR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ANACOR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ANACOR.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(VARIANCES))\\b'
      }
      { include: '#subcomTable' }
      { include: '#subcomDimension' }
      { include: '#subcomNormalization' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMatrix' }
      {
        comment: 'Valid keywords for ANACOR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(OUT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  analysisOfVariance: {
    comment: 'ANOVA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ANOVA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ANOVA.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(COVARIATES|MAXORDERS))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomMethod' }
      { include: '#subcomStatistics' }
      { include: '#subcomMissing' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  applyDictionary: {
    comment: 'APPLY DICTIONARY Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(APPLY DICTIONARY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to APPLY DICTIONARY.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(NEWVARS))\\b'
      }
      { include: '#subcomFrom' }
      { include: '#subcomSource' }
      { include: '#subcomTarget' }
      { include: '#subcomFileInfo' }
      { include: '#subcomVarInfo' }
      {
        comment: 'Valid keywords for ANACOR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD|ATTRIBUTES|ALIGNMENT|DOCUMENTS|FILELABEL|FORMATS|LEVEL
          |MRSETS|VARSETS|WEIGHT|MISSING|ROLE|VALLABELS|WIDTH))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aregCommand: {
    comment: 'AREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(RHO|MXITER))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomMethod' }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomApply' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  arimaCommand: {
    comment: 'ARIMA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ARIMA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ARIMA.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(CINPCT|FORECAST))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomModel' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for ARIMA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(P|D|Q|SP|SD|SQ|AR|MA|SAR|SMA|REG|CON|CONSTANT|NOCONSTANT
          |NOLOG|LG10|LN|MXITER|PAREPS|SSQPCT|MXLAMB|SPECIFICATIONS|INITIAL|FIT|EXACT
          |CLS|AUTOINIT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  autoRecode: {
    comment: 'AUTORECODE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AUTORECODE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AUTORECODE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(BLANK|GROUP|SAVE TEMPLATE|APPLY TEMPLATE|DESCENDING))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomInto' }
      { include: '#subcomPrint' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesANOVA: {
    comment: 'BAYES ANOVA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES ANOVA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES ANOVA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|REGWGT|VARIABLES|ANALYSIS|COMPUTATION
          |TYPE|SHAPEPARAM|SCALEPARAM|MEANVECTOR|VMATRIX|MEANS|ERRORVAR))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesCorrelation: {
    comment: 'BAYES CORRELATION Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES CORRELATION))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      {
        comment: 'Valid keywords for BAYES CORRELATION.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|TOL|MAXITER|MCSAMPLES|POSTSAMPLES|VARIABLES
          |ANALYSIS|CVALUE|MAXPLOTS|TYPE|NULLVALUE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesIndependent: {
    comment: 'BAYES INDEPENDENT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES INDEPENDENT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES INDEPENDENT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|VARIABLES|GROUP|SELECT|DATAVAR|ANALYSIS
          |COMPUTATION|EQUALDATAVAR|VARDIST|MEANDIST))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesLogLinear: {
    comment: 'BAYES LOGLINEAR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES LOGLINEAR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomTable' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrint' }
      {
        comment: 'Valid keywords for BAYES LOGLINEAR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|TOL|MAXITER|POSTSAMPLES|ORDER|ANALYSIS|MODEL
          |FIXMARGIN|FIXMARGINS|FIX_MARGINS|PRIORTYPE|PRIOR_TYPE|SHAPEPARAMS|SCALEPARAM
          |LAMBDAS|SUPPRESSTABLE|SUPPRESS_TABLE|CELLS|STATISTICS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesOneSample: {
    comment: 'BAYES ONESAMPLE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES ONESAMPLE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomData' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES ONESAMPLE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SCOPE|CILEVEL|DISTRIBUTION|VARIABLES|ANALYSIS|SUCCESS
          |NULLPRIORPARAM|ALTERPRIORPARAM|VARDIST|PREDIST|TYPE|METHOD|SEED|TOL|MAXITER
          |MCSAMPLES|VARIANCE|NULLVALUE|ALTERGVALUE|PRECDIST|MEANDIST|KAPPA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRegression: {
    comment: 'BAYES REGRESSION Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES REGRESSION))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BAYES REGRESSION.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PREDICT|FTEST))\\b'
      }
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES REGRESSION.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|REGWGT|FACTORS|COVARIATES|ANALYSIS
          |COMPUTATION|COMPARE|TYPE|SHAPEPARAM|SCALEPARAM|MEANVECTOR|VMATRIX|REGRESSORS
          |PARAMETER|MAX_CATEGORY|INTERCEPT|ERRORVAR|BAYESPRED|LABEL|VARIABLES|TESTVALUES))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRelated: {
    comment: 'BAYES RELATED Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES RELATED))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BAYES RELATED.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PAIR))\\b'
      }
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES RELATED.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SCOPE|CILEVEL|METHOD|SEED|TOL|MAXITER|MCSAMPLES|ANALYSIS
          |VARIABLES|VARIANCE|NULLVALUE|ALTERGVALUE|VARDIST|PRECDIST|MEANDIST|KAPPA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRepeated: {
    comment: 'BAYES REPEATED Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES REPEATED))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES REPEATED.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|MCSAMPLES|REGWGT|ANALYSIS|COMPUTATION|MEANS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginData: {
    comment: 'BEGIN DATA-END DATA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN DATA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END DATA))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginExpr: {
    comment: 'BEGIN EXPR-END EXPR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN EXPR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END EXPR))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  simprepBegin: {
    comment: 'SIMPREP BEGIN-SIMPREP END Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(SIMPREP BEGIN))\\b'
    beginCaptures:
      1: name: 'invalid.deprecated.command.spss'
    end: '\\b(?i:(SIMPREP END))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'invalid.deprecated.command.end.spss'
    patterns: [
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginGPL: {
    comment: 'BEGIN GPL-END GPL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN GPL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END GPL))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for BEGIN GPL-END GPL.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SOURCE|DATA|SCALE|GUIDE|ELEMENT|COORD|PAGE|GRAPH|COMMENT|TRANS))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginProgram: {
    comment: 'BEGIN PROGRAM-END PROGRAM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN PROGRAM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END PROGRAM))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for BEGIN PROGRAM-END PROGRAM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PYTHON3))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bootStrap: {
    comment: 'BOOTSTRAP Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BOOTSTRAP))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BOOTSTRAP.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SAMPLING))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for BOOTSTRAP.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SIMPLE|STRATIFIED|RESIDUAL|WILD|TARGET|INPUT|CILEVEL|CITYPE
          |NSAMPLES|USERMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  casePlot: {
    comment: 'CASEPLOT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CASEPLOT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomID' }
      { include: '#subcomFormat' }
      { include: '#subcomMark' }
      { include: '#subcomSplit' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for CASEPLOT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(REFERENCE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  casesToVars: {
    comment: 'CASESTOVARS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CASESTOVARS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CASESTOVARS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(VIND|AUTOFIX|SEPARATOR|GROUPBY))\\b'
      }
      { include: '#subcomID' }
      { include: '#subcomIndex' }
      { include: '#subcomCount' }
      { include: '#subcomFixed' }
      { include: '#subcomRename' }
      { include: '#subcomDrop' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  catpcaCommand: {
    comment: 'CATPCA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CATPCA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomAnalysis' }
      { include: '#subcomDiscretization' }
      { include: '#subcomMissing' }
      { include: '#subcomSupplementary' }
      { include: '#subcomConfiguration' }
      { include: '#subcomDimension' }
      { include: '#subcomNormalization' }
      { include: '#subcomMaxIter' }
      { include: '#subcomCritIter' }
      { include: '#subcomRotation' }
      { include: '#subcomResample' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CATPCA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WEIGHT|LEVEL|BOOTSTRAP|OBJECT|CATEGORY|LOADING|TRANS|RESID
          |BIPLOT|TRIPLOT|JOINTCAT|PROJCENTR|VAF|LDELLAREA|OBELLAREA|CTELLAREA|NELLPNT
          |NONE|NDIM|CENTR|DISCRDATA|TRDATA|APPROX|ELLCOORD))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  catregCommand: {
    comment: 'CATREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CATREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CATREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(REGULARIZATION))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomAnalysis' }
      { include: '#subcomDiscretization' }
      { include: '#subcomMissing' }
      { include: '#subcomSupplementary' }
      { include: '#subcomInitial' }
      { include: '#subcomMaxIter' }
      { include: '#subcomCritIter' }
      { include: '#subcomResample' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CATREG.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(LEVEL|OBJECT|NONE|RIDGE|LASSO|ENET|CROSSVAL|BOOTSTRAP
          |TRANS|RESID|REGU|DISCRDATA|TRDATA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  ccfCommand: {
    comment: 'CCF Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CCF))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CCF.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(MXCROSS))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomSeasonal' }
      { include: '#subcomApply' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  clusterCommand: {
    comment: 'CLUSTER Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CLUSTER))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMeasure' }
      { include: '#subcomMethod' }
      { include: '#subcomSave' }
      { include: '#subcomID' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMissing' }
      { include: '#subcomMatrix' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  codeBook: {
    comment: 'CODEBOOK Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CODEBOOK))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVarInfo' }
      { include: '#subcomFileInfo' }
      { include: '#subcomStatistics' }
      { include: '#subcomOptions' }
      {
        comment: 'Valid keywords for CODEBOOK.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(MAXCATS|VARORDER|SORT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  compareDatasets: {
    comment: 'COMPARE DATASETS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(COMPARE DATASETS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to COMPARE DATASETS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(COMPDATASET|CASEID))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomSave' }
      { include: '#subcomOutput' }
      {
        comment: 'Valid keywords for COMPARE DATASETS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD|FLAGMISMATCHES|MATCHDATASET|MISMATCHDATASET
          |ENCRYPTEDPW|VARPROPERTIES|CASETABLE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  conjointCommand: {
    comment: 'CONJOINT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CONJOINT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CONJOINT.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SEQUENCE|RANK|SCORE|SUBJECT|UTILITY))\\b'
      }
      { include: '#subcomPlan' }
      { include: '#subcomData' }
      { include: '#subcomFactors' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  correlationsCommand: {
    comment: 'CORRELATIONS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CORRELATIONS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomPrint' }
      { include: '#subcomStatistics' }
      { include: '#subcomMissing' }
      { include: '#subcomMatrix' }
      { include: '#subcomCI' }
      {
        comment: 'Valid keywords for CORRELATIONS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(METHOD|BIAS|CILEVEL))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  correspondenceCommand: {
    comment: 'CORRESPONDENCE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CORRESPONDENCE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CORRESPONDENCE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(EQUAL))\\b'
      }
      { include: '#subcomTable' }
      { include: '#subcomDimension' }
      { include: '#subcomSupplementary' }
      { include: '#subcomMeasure' }
      { include: '#subcomStandardize' }
      { include: '#subcomNormalization' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  coxregCommand: {
    comment: 'COXREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(COXREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomStatus' }
      { include: '#subcomStrata' }
      { include: '#subcomCategorical' }
      { include: '#subcomContrast' }
      { include: '#subcomMethod' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomCriteria' }
      { include: '#subcomPlot' }
      { include: '#subcomPattern' }
      { include: '#subcomOutfile' }
      { include: '#subcomSave' }
      { include: '#subcomExternal' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  createCommand: {
    comment: 'CREATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CREATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CREATE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(CSUM|FFT|IFFT|LAG|LEAD|PMA|RMED|T4253H))\\b'
      }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomMA' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }
  crossTabulation: {
    comment: 'CROSSTABS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CROSSTABS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CROSSTABS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SHOWDIM))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomTables' }
      { include: '#subcomCells' }
      { include: '#subcomStatistics' }
      { include: '#subcomMethod' }
      { include: '#subcomMissing' }
      { include: '#subcomFormat' }
      { include: '#subcomCount' }
      { include: '#subcomBarChart' }
      { include: '#subcomWrite' }
      { include: '#subcomHideSmallCounts' }
      {
        comment: 'Valid keywords for CROSSTABS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(COUNT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csCoxReg: {
    comment: 'CSCOXREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSCOXREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CSCOXREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(TESTASSUMPTIONS|SURVIVALMETHOD))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomCustom' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomPlot' }
      { include: '#subcomPattern' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSCOXREG.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(STATUS|BASELINESTRATA|FILE|CILEVEL|DF|LCONVERGE|MXITER
          |MXSTEP|PCONVERGE|SINGULAR|TIES|TYPE|PADJUST|PROPHAZARD|PARAMETER|COVB
          |BASELINE|CI|CORB|SURVIVAL|LABEL|LMATRIX|KMATRIX|CLASSMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csDescriptives: {
    comment: 'CSDESCRIPTIVES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSDESCRIPTIVES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CSDESCRIPTIVES.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(RATIO))\\b'
      }
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomSummary' }
      { include: '#subcomMean' }
      { include: '#subcomSum' }
      { include: '#subcomStatistics' }
      { include: '#subcomSubPop' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for CSDESCRIPTIVES.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|VARIABLES|TTEST|VALUE|VALUELIST|DISPLAY|SCOPE|CLASSMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csGLM: {
    comment: 'CSGLM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSGLM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomIntercept' }
      { include: '#subcomCustom' }
      { include: '#subcomEMMeans' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSGLM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|INCLUDE|SHOW|TABLES|OTHER|CONTRAST|COMPARE|CILEVEL|DF
          |SINGULAR|TYPE|PADJUST|CLASSMISSING|COVB|CORB|PARAMETER|LABEL|LMATRIX|KMATRIX))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csLogistic: {
    comment: 'CSLOGISTIC Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSLOGISTIC))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomIntercept' }
      { include: '#subcomCustom' }
      { include: '#subcomOddsRatios' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSLOGISTIC.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|INCLUDE|SHOW|LABEL|FACTOR|COVARIATE|CONTROL|CHKSEP
          |CILEVEL|DF|LCONVERGE|MXITER|MXSTEP|PCONVERGE|SINGULAR|TYPE|PADJUST|VARIABLE
          |CLASSMISSING|COVB|CORB|PARAMETER|LMATRIX|KMATRIX))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csOrdinal: {
    comment: 'CSORDINAL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSORDINAL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomLink' }
      { include: '#subcomCustom' }
      { include: '#subcomOddsRatios' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomNonParallel' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSORDINAL.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|FUNCTION|LABEL|LMATRIX|KMATRIX|FACTOR|COVARIATE|CONTROL
          |CHKSEP|CILEVEL|DF|LCONVERGE|METHOD|MXITER|MXSTEP|PCONVERGE|SINGULAR|TYPE
          |PADJUST|CLASSMISSING|COVB|CORB|PARAMETER))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csPlan: {
    comment: 'CSPLAN Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSPLAN))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomPlanVars' }
      { include: '#subcomSRSEstimator' }
      { include: '#subcomPrint' }
      { include: '#subcomDesign' }
      { include: '#subcomMethod' }
      { include: '#subcomSize' }
      { include: '#subcomRate' }
      { include: '#subcomMOS' }
      { include: '#subcomStageVars' }
      { include: '#subcomEstimator' }
      { include: '#subcomPopSize' }
      { include: '#subcomInclProb' }
      {
        comment: 'Valid keywords for CSPLAN.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|ANALYSISWEIGHT|SAMPLEWEIGHT|PREVIOUSWEIGHT|STAGELABEL
          |STRATA|CLUSTER|ESTIMATION|VALUE|MATRIX|VARIABLE|MINSIZE|MAXSIZE|SOURCE
          |MIN|MAX))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csSelect: {
    comment: 'CSSELECT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSSELECT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomCriteria' }
      { include: '#subcomClassMissing' }
      { include: '#subcomData' }
      { include: '#subcomSampleFile' }
      { include: '#subcomJointProb' }
      { include: '#subcomSelectRule' }
      { include: '#subcomPrint' }
      {
        comment: 'Valid keywords for CSSELECT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|STAGES|SEED|RENAMEVARS|PRESORTED|OUTFILE|KEEP|DROP))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csTabulate: {
    comment: 'CSTABULATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSTABULATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomTables' }
      { include: '#subcomCells' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomSubPop' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for CSTABULATE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|VARIABLES|DISPLAY|SCOPE|CLASSMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  customTables: {
    comment: 'CTABLES Command (DMTABLES alias)'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CTABLES|DMTABLES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomTable' }
      { include: '#subcomSLabels' }
      { include: '#subcomCLabels' }
      { include: '#subcomCategories' }
      { include: '#subcomCriteria' }
      { include: '#subcomTitles' }
      { include: '#subcomFormat' }
      { include: '#subcomVLabels' }
      { include: '#subcomSMissing' }
      { include: '#subcomMRSets' }
      { include: '#subcomWeight' }
      { include: '#subcomPCompute' }
      { include: '#subcomPProperties' }
      { include: '#subcomHideSmallCounts' }
      {
        comment: 'Valid keywords for CTABLES.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(POSITION|VISIBLE|ROWLABELS|COLLABELS|MISSING|OTHERNM|SUBTOTAL
          |HSUBTOTAL|ORDER|KEY|TOTAL|LABEL|EMPTY|CILEVEL|CAPTION|CORNER|TITLE|TYPE
          |ALPHA|INCLUDEMRSETS|ADJUST|MEANSVARIANCE|MERGE|STYLE|SHOWSIG|ORIGIN
          |MINCOLWIDTH|MAXCOLWIDTH|UNITS|VARIABLES|DISPLAY|COUNTDUPLICATES|FORMAT
          |HIDESOURCECATS|COUNT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  curveFit: {
    comment: 'CURVEFIT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CURVEFIT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomModel' }
      { include: '#subcomUpperBound' }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomCIN' }
      { include: '#subcomPlot' }
      { include: '#subcomID' }
      { include: '#subcomSave' }
      { include: '#subcomPrint' }
      { include: '#subcomApply' }
      { include: '#subcomTemplate' }
      {
        comment: 'Valid keywords for CURVEFIT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ANOVA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  dataList: {
    comment: 'DATA LIST Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATA LIST))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomEncoding' }
      { include: '#subcomTable' }
      { include: '#subcomNoTable' }
      { include: '#subcomRecords' }
      { include: '#subcomSkip' }
      {
        comment: 'Valid keywords for DATA LIST.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FIXED|FREE|LIST))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datafileAttribute: {
    comment: 'DATAFILE ATTRIBUTE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATAFILE ATTRIBUTE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATAFILE ATTRIBUTE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ATTRIBUTE|DELETE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetActivate: {
    comment: 'DATASET ACTIVATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET ACTIVATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET ACTIVATE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetCopy: {
    comment: 'DATASET COPY Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET COPY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET COPY.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetDeclare: {
    comment: 'DATASET DECLARE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET DECLARE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET DECLARE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetName: {
    comment: 'DATASET NAME Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET NAME))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET NAME.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  dateCommand: {
    comment: 'DATASET NAME Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET NAME))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET NAME.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(YEAR|QUARTER|MONTH|WEEK|DAY|HOUR|MINUTE|SECOND|CYCLE|OBS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  defineEndDefine: {
    comment: 'DEFINE-!ENDDEFINE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DEFINE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(!)\\b(?i:(ENDDEFINE))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMPrint' }
      { include: '#subcomMExpand' }
      { include: '#subcomMNest' }
      { include: '#subcomMIterate' }
      {
        comment: 'Valid keywords for BEGIN PROGRAM-END PROGRAM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PRESERVE|RESTORE))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  descriptivesCommand: {
    comment: 'DESCRIPTIVES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DESCRIPTIVES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomSave' }
      { include: '#subcomStatistics' }
      { include: '#subcomSort' }
      { include: '#subcomMissing' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  detectAnomaly: {
    comment: 'DETECTANOMALY Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DETECTANOMALY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomHandleMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      { include: '#subcomPrint' }
      {
        comment: 'Valid keywords for DETECTANOMALY.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CATEGORICAL|SCALE|ID|EXCEPT|APPLY|CREATEMISPROPVAR
          |MINNUMPEERS|MAXNUMPEERS|MLWEIGHT|NUMREASONS|PCTANOMALOUSCASES
          |NUMANOMALOUSCASES|ANOMALYCUTPOINT|MODEL))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  discriminantCommand: {
    comment: 'DISCRIMINANT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DISCRIMINANT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomGroups' }
      { include: '#subcomVariables' }
      { include: '#subcomSelect' }
      { include: '#subcomAnalysis' }
      { include: '#subcomMethod' }
      { include: '#subcomOutfile' }
      { include: '#subcomTolerance' }
      { include: '#subcomPIN' }
      { include: '#subcomPOUT' }
      { include: '#subcomFIN' }
      { include: '#subcomFOUT' }
      { include: '#subcomVIN' }
      { include: '#subcomMaxSteps' }
      { include: '#subcomFunctions' }
      { include: '#subcomPriors' }
      { include: '#subcomSave' }
      { include: '#subcomStatistics' }
      { include: '#subcomRotate' }
      { include: '#subcomHistory' }
      { include: '#subcomClassify' }
      { include: '#subcomPlot' }
      { include: '#subcomMissing' }
      { include: '#subcomMatrix' }
      {
        comment: 'Valid keywords for DISCRIMINANT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(MODEL|MAX|IN|OUT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  displayCommand: {
    comment: 'DISPLAY Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DISPLAY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      {
        comment: 'Valid keywords for DISPLAY.'
        name: 'keyword.other.spss'
        match: '((/?)\\b(?i:(SORTED|NAMES|DOCUMENTS|DICTIONARY|ATTRIBUTES|INDEX|LABELS
          |SCRATCH|VECTOR|MACROS))\\b)|((/?)(@)(\\b(?i:(ATTRIBUTES))\\b))'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  eraseCommand: {
    comment: 'ERASE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ERASE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for ERASE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  examineCommand: {
    comment: 'EXAMINE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(EXAMINE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomCompare' }
      { include: '#subcomTotal' }
      { include: '#subcomNoTotal' }
      { include: '#subcomID' }
      { include: '#subcomPercentiles' }
      { include: '#subcomPlot' }
      { include: '#subcomStatistics' }
      { include: '#subcomCInterval' }
      { include: '#subcomMEstimators' }
      { include: '#subcomMissing' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  exportCommand: {
    comment: 'EXPORT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(EXPORT))\\b'
    beginCaptures:
      1: name: 'invalid.deprecated.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'invalid.deprecated.command.end.spss'
    patterns: [
      { include: '#subcomOutfile' }
      { include: '#subcomType' }
      { include: '#subcomUnselected' }
      { include: '#subcomDrop' }
      { include: '#subcomKeep' }
      { include: '#subcomRename' }
      { include: '#subcomMap' }
      { include: '#subcomDigits' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  exSmooth: {
    comment: 'EXSMOOTH Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(EXSMOOTH))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomModel' }
      { include: '#subcomPeriod' }
      { include: '#subcomSeasFact' }
      { include: '#subcomInitial' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for EXSMOOTH.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ALPHA|GAMMA|DELTA|PHI|GRID))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  extensionCommand: {
    comment: 'EXTENSION Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(EXTENSION))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomSpecification' }
      {
        comment: 'Valid keywords for EXTENSION.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ACTION|COMMAND))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  factorCommand: {
    comment: 'FACTOR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FACTOR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomMissing' }
      { include: '#subcomMethod' }
      { include: '#subcomSelect' }
      { include: '#subcomAnalysis' }
      { include: '#subcomFormat' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomDiagonal' }
      { include: '#subcomCriteria' }
      { include: '#subcomExtraction' }
      { include: '#subcomRotation' }
      { include: '#subcomSave' }
      { include: '#subcomMatrix' }
      {
        comment: 'Valid keywords for FACTOR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(OUT|IN))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  fileHandle: {
    comment: 'FILE HANDLE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FILE HANDLE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomName' }
      { include: '#subcomMode' }
      { include: '#subcomRecForm' }
      { include: '#subcomLRECL' }
      { include: '#subcomEncoding' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  fileType: {
    comment: 'FILE TYPE-END FILE TYPE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FILE TYPE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END FILE TYPE))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomEncoding' }
      { include: '#subcomRecord' }
      { include: '#subcomCase' }
      { include: '#subcomWild' }
      { include: '#subcomDuplicate' }
      { include: '#subcomMissing' }
      { include: '#subcomOrdered' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  filterCommand: {
    comment: 'FILTER Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FILTER))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for FILTER.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(OFF))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  fitCommand: {
    comment: 'FIT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FIT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomErrors' }
      { include: '#subcomOBS' }
      { include: '#subcomDFE' }
      { include: '#subcomDFH' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  fleissMultiraterKappa: {
    comment: 'FLEISS MULTIRATER KAPPA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FLEISS MULTIRATER KAPPA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomPrint' }
      {
        comment: 'Valid keywords for FLEISS MULTIRATER KAPPA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CLASSMISSING|ASYMPTOTIC_CILEVEL|IGNORE_CASE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  flipCommand: {
    comment: 'FLIP Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FLIP))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomNewNames' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  frequenciesCommand: {
    comment: 'FREQUENCIES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(FREQUENCIES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomFormat' }
      { include: '#subcomBarChart' }
      { include: '#subcomPieChart' }
      { include: '#subcomHistogram' }
      { include: '#subcomGrouped' }
      { include: '#subcomPercentiles' }
      { include: '#subcomNTiles' }
      { include: '#subcomStatistics' }
      { include: '#subcomMissing' }
      { include: '#subcomOrder' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  generalizedLinear: {
    comment: 'GENLIN Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GENLIN))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomModel' }
      { include: '#subcomCriteria' }
      { include: '#subcomRepeated' }
      { include: '#subcomEMMeans' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for GENLIN.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(INTERCEPT|OFFSET|SCALEWEIGHT|DISTRIBUTION|LINK|ANALYSISTYPE
          |CHECKSEP|CILEVEL|CITYPE|COVB|HCONVERGE|INITIAL|LCONVERGE|LIKELIHOOD
          |MAXITERATIONS|MAXSTEPHALVING|METHOD|PCONVERGE|SCALE|SINGULAR|SUBJECT
          |WITHINSUBJECT|SORT|CORRTYPE|ADJUSTCORR|UPDATECORR|TABLES|CONTROL|COMPARE
          |CONTRAST|PADJUST|CLASSMISSING|CORB|PARAMETER))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  generalizedLinearMixed: {
    comment: 'GENLINMIXED Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GENLINMIXED))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomDataStructure' }
      { include: '#subcomFields' }
      { include: '#subcomTargetOptions' }
      { include: '#subcomFixed' }
      { include: '#subcomRandom' }
      { include: '#subcomBuildOptions' }
      { include: '#subcomEMMeans' }
      { include: '#subcomEMMeansOptions' }
      { include: '#subcomOutfile' }
      { include: '#subcomSave' }
      {
        comment: 'Valid keywords for GENLINMIXED.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SUBJECTS|REPEATED_MEASURES|KNONECKER_MEASURES|GROUPING
          |COVARIANCE_TYPE|SPCOORDS|TARGET|TRIALS|ANALYSIS_WEIGHT|OFFSET|REFERENCE
          |DISTRIBUTION|LINK|LINKPARAMETER|EFFECTS|USE_INTERCEPT|SOLUTION
          |TARGET_CATEGORY_ORDER|INPUTS_CATEGORY_ORDER|MAX_ITERATIONS|CONFIDENCE_LEVEL
          |DF_METHOD|COVB|PCONVERGE|LCONVERGE|HCONVERGE|SCORING|SINGULAR|TABLES|COMPARE
          |CONTRAST|CONTROL|SCALE|PADJUST|MODEL|MAX_CATEGORIES))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  generalizedLog: {
    comment: 'GENLOG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GENLOG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCStructure' }
      { include: '#subcomGResid' }
      { include: '#subcomGLOR' }
      { include: '#subcomModel' }
      { include: '#subcomCriteria' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMissing' }
      { include: '#subcomSave' }
      { include: '#subcomDesign' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getCommand: {
    comment: 'GET Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GET))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomDrop' }
      { include: '#subcomKeep' }
      { include: '#subcomRename' }
      { include: '#subcomMap' }
      {
        comment: 'Valid keywords for GET.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(LOCK|PASSWORD))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getCapture: {
    comment: 'GET CAPTURE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GET CAPTURE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomConnect' }
      { include: '#subcomUnencrypted' }
      { include: '#subcomSQL' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getData: {
    comment: 'GET DATA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GET DATA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomType' }
      { include: '#subcomFile' }
      { include: '#subcomConnect' }
      { include: '#subcomEncrypted' }
      { include: '#subcomUnencrypted' }
      { include: '#subcomSQL' }
      { include: '#subcomAssumedStrWidth' }
      { include: '#subcomDataTypeMin' }
      { include: '#subcomLeadingSpaces' }
      { include: '#subcomSheet' }
      { include: '#subcomCellRange' }
      { include: '#subcomReadNames' }
      { include: '#subcomHidden' }
      { include: '#subcomTrailingSpaces' }
      { include: '#subcomEncoding' }
      { include: '#subcomArrangement' }
      { include: '#subcomFirstCase' }
      { include: '#subcomDelCase' }
      { include: '#subcomFixCase' }
      { include: '#subcomImportCase' }
      { include: '#subcomDelimiters' }
      { include: '#subcomMultipleSpaces' }
      { include: '#subcomQualifier' }
      { include: '#subcomVariables' }
      {
        comment: 'Valid keywords for GET DATA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PERCENTAGE|IGNORE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getSAS: {
    comment: 'GET SAS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GET SAS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomData' }
      { include: '#subcomEncoding' }
      { include: '#subcomFormats' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getStata: {
    comment: 'GET STATA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GET STATA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomEncoding' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getTranslate: {
    comment: 'GET TRANSLATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GET TRANSLATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomType' }
      { include: '#subcomFieldNames' }
      { include: '#subcomRange' }
      { include: '#subcomDrop' }
      { include: '#subcomKeep' }
      { include: '#subcomMap' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getCognos: {
    comment: 'GETCOGNOS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GETCOGNOS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMode' }
      { include: '#subcomConnection' }
      { include: '#subcomLocation' }
      { include: '#subcomImport' }
      { include: '#subcomFilter' }
      { include: '#subcomParameters' }
      {
        comment: 'Valid keywords for GETCOGNOS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(TYPE|SERVERURL|MODE|CREDENTIALS|NAMESPACE|USERNAME|PASSWORD
          |STOREDCREDENTIAL|PACKAGE|FIELDS|REPORT|VALUE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  getTM1: {
    comment: 'GETTM1 Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GETTM1))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomConnection' }
      { include: '#subcomView' }
      { include: '#subcomRename' }
      {
        comment: 'Valid keywords for GETTM1.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PMSYSURL|SERVER|MODE|USERNAME|PASSWORD|NAMESPACE|CREDENTIAL
          |CUBE|NAME|FIELDS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  ggraphCommand: {
    comment: 'GGRAPH Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GGRAPH))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomGraphDataSet' }
      { include: '#subcomGraphSpec' }
      { include: '#subcomColorCycle' }
      { include: '#subcomFrame' }
      { include: '#subcomGridLines' }
      { include: '#subcomFitLines' }
      {
        comment: 'Valid keywords for GGRAPH.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(NAME|VARIABLES|DATASET|LEVEL|VALUES|UNLABELED|SOURCE|LOCATION
          |EDITABLE|LABEL|DEFAULTTEMPLATE|TEMPLATE|VIZSTYLESHEET|VIZMAP|MAPKEY
          |SHOWALLFEATURES|OUTER|INNER|XAXIS|YAXIS|TOTAL|SUBGROUPS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  generalLinearModel: {
    comment: 'GLM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GLM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomRandom' }
      { include: '#subcomRegWgt' }
      { include: '#subcomMethod' }
      { include: '#subcomIntercept' }
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomTest' }
      { include: '#subcomLMatrix' }
      { include: '#subcomKMatrix' }
      { include: '#subcomContrast' }
      { include: '#subcomPostHoc' }
      { include: '#subcomEMMeans' }
      { include: '#subcomRobust' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      { include: '#subcomMBPDesign' }
      { include: '#subcomBPDesign' }
      { include: '#subcomFDesign' }
      { include: '#subcomDesign' }
      { include: '#subcomMMatrix' }
      { include: '#subcomWSFactor' }
      { include: '#subcomWSDesign' }
      { include: '#subcomMeasure' }
      {
        comment: 'Valid keywords for GLM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(INTERCEPT|OVERALL|WITHIN|TYPE|ERRORBAR))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  graphCommand: {
    comment: 'GRAPH Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(GRAPH))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomTitle' }
      { include: '#subcomSubTitle' }
      { include: '#subcomFootNote' }
      { include: '#subcomBar' }
      { include: '#subcomLine' }
      { include: '#subcomPie' }
      { include: '#subcomHilo' }
      { include: '#subcomErrorBar' }
      { include: '#subcomScatterPlot' }
      { include: '#subcomHistogram' }
      { include: '#subcomPareto' }
      { include: '#subcomPanel' }
      { include: '#subcomInterval' }
      { include: '#subcomTemplate' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for GRAPH.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(COLVAR|COLOP|ROWVAR|ROWOP|CI|STDDEV|SE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  hierarchicalLogLinear: {
    comment: 'HILOGLINEAR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(HILOGLINEAR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMethod' }
      { include: '#subcomMaxOrder' }
      { include: '#subcomCriteria' }
      { include: '#subcomCWeight' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMissing' }
      { include: '#subcomDesign' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  homalsCommand: {
    comment: 'HOMALS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(HOMALS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomAnalysis' }
      { include: '#subcomNObservations' }
      { include: '#subcomDimension' }
      { include: '#subcomMaxIter' }
      { include: '#subcomConvergence' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomSave' }
      { include: '#subcomMatrix' }
      {
        comment: 'Valid keywords for HOMALS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(OUT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  hostCommand: {
    comment: 'HOST Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(HOST))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for HOST.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(COMMAND|TIMELIMIT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  iGraphCommand: {
    comment: 'IGRAPH Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(IGRAPH))\\b'
    beginCaptures:
      1: name: 'invalid.deprecated.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'invalid.deprecated.command.end.spss'
    patterns: [
      # Not bothering with matching subcoms since this is deprecated as of SPSS 18.
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  importCommand: {
    comment: 'IMPORT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(IMPORT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomType' }
      { include: '#subcomDrop' }
      { include: '#subcomKeep' }
      { include: '#subcomRename' }
      { include: '#subcomMap' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  # Common subcommands:
  subcomAnalysis: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ANALYSIS))\\b'
  }
  subcomApply: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(APPLY))\\b'
  }
  subcomArrangement: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ARRANGEMENT))\\b'
  }
  subcomAssumedStrWidth: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ASSUMEDSTRWIDTH))\\b'
  }
  subcomBar: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(BAR))\\b'
  }
  subcomBarChart: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(BARCHART))\\b'
  }
  subcomBPDesign: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(BPDESIGN))\\b'
  }
  subcomBuildOptions: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(BUILD_OPTIONS))\\b'
  }
  subcomCase: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CASE))\\b'
  }
  subcomCategorical: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CATEGORICAL))\\b'
  }
  subcomCategories: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CATEGORIES))\\b'
  }
  subcomCellRange: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CELLRANGE))\\b'
  }
  subcomCells: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CELLS))\\b'
  }
  subcomCI: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CI))\\b'
  }
  subcomCIN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CIN))\\b'
  }
  subcomCInterval: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CINTERVAL))\\b'
  }
  subcomCLabels: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CLABELS))\\b'
  }
  subcomClassify: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CLASSIFY))\\b'
  }
  subcomClassMissing: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CLASSMISSING))\\b'
  }
  subcomColorCycle: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(COLORCYCLE))\\b'
  }
  subcomCompare: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(COMPARE))\\b'
  }
  subcomCondition: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONDITION))\\b'
  }
  subcomConnect: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONNECT))\\b'
  }
  subcomConnection: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONNECTION))\\b'
  }
  subcomConfiguration: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONFIGURATION))\\b'
  }
  subcomConstant: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONSTANT))\\b'
  }
  subcomContinuous: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONTINUOUS))\\b'
  }
  subcomContrast: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONTRAST))\\b'
  }
  subcomConvergence: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONVERGENCE))\\b'
  }
  subcomCount: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(COUNT))\\b'
  }
  subcomCriteria: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CRITERIA))\\b'
  }
  subcomCritIter: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CRITITER))\\b'
  }
  subcomCStructure: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CSTRUCTURE))\\b'
  }
  subcomCustom: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CUSTOM))\\b'
  }
  subcomCWeight: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CWEIGHT))\\b'
  }
  subcomData: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DATA))\\b'
  }
  subcomDataStructure: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DATA_STRUCTURE))\\b'
  }
  subcomDataTypeMin: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DATATYPEMIN))\\b'
  }
  subcomDelCase: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DELCASE))\\b'
  }
  subcomDelimiters: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DELIMITERS))\\b'
  }
  subcomDesign: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DESIGN))\\b'
  }
  subcomDFE: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DFE))\\b'
  }
  subcomDFH: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DFH))\\b'
  }
  subcomDiagonal: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIAGONAL))\\b'
  }
  subcomDiff: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIFF))\\b'
  }
  subcomDigits: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIGITS))\\b'
  }
  subcomDimension: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIMENSION))\\b'
  }
  subcomDiscretization: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DISCRETIZATION))\\b'
  }
  subcomDomain: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DOMAIN))\\b'
  }
  subcomDrop: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DROP))\\b'
  }
  subcomDuplicate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DUPLICATE))\\b'
  }
  subcomEMMeans: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(EMMEANS))\\b'
  }
  subcomEMMeansOptions: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(EMMEANS_OPTIONS))\\b'
  }
  subcomEncoding: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ENCODING))\\b'
  }
  subcomEncrypted: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ENCRYPTED))\\b'
  }
  subcomErrorBar: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ERRORBAR))\\b'
  }
  subcomErrors: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ERRORS))\\b'
  }
  subcomESTBF: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ESTBF))\\b'
  }
  subcomEstimator: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ESTIMATOR))\\b'
  }
  subcomExternal: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(EXTERNAL))\\b'
  }
  subcomExtraction: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(EXTRACTION))\\b'
  }
  subcomFactors: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FACTORS))\\b'
  }
  subcomFDesign: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FDESIGN))\\b'
  }
  subcomFGT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FGT))\\b'
  }
  subcomFieldNames: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIELDNAMES))\\b'
  }
  subcomFields: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIELDS))\\b'
  }
  subcomFile: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FILE))\\b'
  }
  subcomFileInfo: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FILEINFO))\\b'
  }
  subcomFilter: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FILTER))\\b'
  }
  subcomFIN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIN))\\b'
  }
  subcomFirst: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIRST))\\b'
  }
  subcomFirstCase: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIRSTCASE))\\b'
  }
  subcomFitLines: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FITLINES))\\b'
  }
  subcomFixCase: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIXCASE))\\b'
  }
  subcomFixed: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIXED))\\b'
  }
  subcomFLT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FLT))\\b'
  }
  subcomFootNote: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FOOTNOTE))\\b'
  }
  subcomFormat: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FORMAT))\\b'
  }
  subcomFormats: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FORMATS))\\b'
  }
  subcomFOUT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FOUT))\\b'
  }
  subcomFrame: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FRAME))\\b'
  }
  subcomFrom: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FROM))\\b'
  }
  subcomFunctions: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FUNCTIONS))\\b'
  }
  subcomGLOR: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(GLOR))\\b'
  }
  subcomGraphDataSet: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(GRAPHDATASET))\\b'
  }
  subcomGraphSpec: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(GRAPHSPEC))\\b'
  }
  subcomGResid: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(GRESID))\\b'
  }
  subcomGridLines: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(GRIDLINES))\\b'
  }
  subcomGrouped: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(GROUPED))\\b'
  }
  subcomGroups: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(GROUPS))\\b'
  }
  subcomHandleMissing: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(HANDLEMISSING))\\b'
  }
  subcomHidden: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(HIDDEN))\\b'
  }
  subcomHideSmallCounts: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(HIDESMALLCOUNTS))\\b'
  }
  subcomHilo: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(HILO))\\b'
  }
  subcomHistogram: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(HISTOGRAM))\\b'
  }
  subcomHistory: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(HISTORY))\\b'
  }
  subcomID: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ID))\\b'
  }
  subcomImport: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(IMPORT))\\b'
  }
  subcomImportCase: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(IMPORTCASE))\\b'
  }
  subcomIn: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(IN))\\b'
  }
  subcomInclProb: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INCLPROB))\\b'
  }
  subcomIndex: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INDEX))\\b'
  }
  subcomInference: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INFERENCE))\\b'
  }
  subcomInitial: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INITIAL))\\b'
  }
  subcomInput: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INPUT))\\b'
  }
  subcomIntercept: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INTERCEPT))\\b'
  }
  subcomInterval: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INTERVAL))\\b'
  }
  subcomInto: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INTO))\\b'
  }
  subcomJointProb: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(JOINTPROB))\\b'
  }
  subcomKeep: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(KEEP))\\b'
  }
  subcomKMatrix: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(KMATRIX))\\b'
  }
  subcomLast: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LAST))\\b'
  }
  subcomLeadingSpaces: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LEADINGSPACES))\\b'
  }
  subcomLine: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LINE))\\b'
  }
  subcomLink: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LINK))\\b'
  }
  subcomLMatrix: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LMATRIX))\\b'
  }
  subcomLocation: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LOCATION))\\b'
  }
  subcomLRECL: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LRECL))\\b'
  }
  subcomMA: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MA))\\b'
  }
  subcomMap: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAP))\\b'
  }
  subcomMark: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MARK))\\b'
  }
  subcomMatrix: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MATRIX))\\b'
  }
  subcomMax: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAX))\\b'
  }
  subcomMaxIter: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAXITER))\\b'
  }
  subcomMaxOrder: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAXORDER))\\b'
  }
  subcomMaxSteps: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAXSTEPS))\\b'
  }
  subcomMBPDesign: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MBPDESIGN))\\b'
  }
  subcomMean: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEAN))\\b'
  }
  subcomMeasure: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEASURE))\\b'
  }
  subcomMedian: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEDIAN))\\b'
  }
  subcomMEstimators: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MESTIMATORS))\\b'
  }
  subcomMethod: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(METHOD))\\b'
  }
  subcomMExpand: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEXPAND))\\b'
  }
  subcomMin: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MIN))\\b'
  }
  subcomMissing: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MISSING))\\b'
  }
  subcomMIterate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MITERATE))\\b'
  }
  subcomMMatrix: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MMATRIX))\\b'
  }
  subcomMNest: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MNEST))\\b'
  }
  subcomMode: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MODE))\\b'
  }
  subcomModel: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MODEL))\\b'
  }
  subcomMOS: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MOS))\\b'
  }
  subcomMPrint: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MPRINT))\\b'
  }
  subcomMRSets: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MRSETS))\\b'
  }
  subcomMultipleSpaces: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MULTIPLESPACES))\\b'
  }
  subcomMXAuto: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MXAUTO))\\b'
  }
  subcomN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(N))\\b'
  }
  subcomNU: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NU))\\b'
  }
  subcomName: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NAME))\\b'
  }
  subcomNaturalLogarithm: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LN))\\b'
  }
  subcomNewNames: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NEWNAMES))\\b'
  }
  subcomNMiss: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NMISS))\\b'
  }
  subcomNUMiss: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NUMISS))\\b'
  }
  subcomNObservations: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOBSERVATIONS))\\b'
  }
  subcomNoConstant: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOCONSTANT))\\b'
  }
  subcomNoLog: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOLOG))\\b'
  }
  subcomNonParallel: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NONPARALLEL))\\b'
  }
  subcomNormalization: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NORMALIZATION))\\b'
  }
  subcomNoTable: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOTABLE))\\b'
  }
  subcomNoTotal: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOTOTAL))\\b'
  }
  subcomNTiles: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NTILES))\\b'
  }
  subcomOBS: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OBS))\\b'
  }
  subcomOddsRatios: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ODDSRATIOS))\\b'
  }
  subcomOptions: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OPTIONS))\\b'
  }
  subcomOrder: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ORDER))\\b'
  }
  subcomOrdered: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ORDERED))\\b'
  }
  subcomOutfile: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OUTFILE))\\b'
  }
  subcomOutput: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OUTPUT))\\b'
  }
  subcomPanel: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PANEL))\\b'
  }
  subcomParameters: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PARAMETERS))\\b'
  }
  subcomPareto: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PARETO))\\b'
  }
  subcomPattern: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PATTERN))\\b'
  }
  subcomPCompute: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PCOMPUTE))\\b'
  }
  subcomPercentiles: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PERCENTILES))\\b'
  }
  subcomPeriod: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PERIOD))\\b'
  }
  subcomPGT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PGT))\\b'
  }
  subcomPie: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PIE))\\b'
  }
  subcomPieChart: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PIECHART))\\b'
  }
  subcomPIN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PIN))\\b'
  }
  subcomPlan: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLAN))\\b'
  }
  subcomPlanVars: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLANVARS))\\b'
  }
  subcomPLT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLT))\\b'
  }
  subcomPlot: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLOT))\\b'
  }
  subcomPopSize: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(POPSIZE))\\b'
  }
  subcomPostHoc: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(POSTHOC))\\b'
  }
  subcomPOUT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(POUT))\\b'
  }
  subcomPProperties: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PPROPERTIES))\\b'
  }
  subcomPrint: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PRINT))\\b'
  }
  subcomPrior: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PRIOR))\\b'
  }
  subcomPriors: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PRIORS))\\b'
  }
  subcomQualifier: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(QUALIFIER))\\b'
  }
  subcomRandom: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RANDOM))\\b'
  }
  subcomRange: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RANGE))\\b'
  }
  subcomRate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RATE))\\b'
  }
  subcomReadNames: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(READNAMES))\\b'
  }
  subcomRecForm: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RECFORM))\\b'
  }
  subcomRecord: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RECORD))\\b'
  }
  subcomRecords: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RECORDS))\\b'
  }
  subcomRegWgt: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(REGWGT))\\b'
  }
  subcomRename: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RENAME))\\b'
  }
  subcomRepeated: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(REPEATED))\\b'
  }
  subcomResample: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RESAMPLE))\\b'
  }
  subcomRescale: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RESCALE))\\b'
  }
  subcomRobust: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ROBUST))\\b'
  }
  subcomRotate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ROTATE))\\b'
  }
  subcomRotation: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ROTATION))\\b'
  }
  subcomSampleFile: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SAMPLEFILE))\\b'
  }
  subcomSave: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SAVE))\\b'
  }
  subcomScatterPlot: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SCATTERPLOT))\\b'
  }
  subcomScreening: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SCREENING))\\b'
  }
  subcomSDiff: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SDIFF))\\b'
  }
  subcomSeasFact: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SEASFACT))\\b'
  }
  subcomSeasonal: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SEASONAL))\\b'
  }
  subcomSelect: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SELECT))\\b'
  }
  subcomSelectRule: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SELECTRULE))\\b'
  }
  subcomShape: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SHAPE))\\b'
  }
  subcomSheet: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SHEET))\\b'
  }
  subcomSize: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SIZE))\\b'
  }
  subcomSkip: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SKIP))\\b'
  }
  subcomSLabels: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SLABELS))\\b'
  }
  subcomSMissing: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SMISSING))\\b'
  }
  subcomSort: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SORT))\\b'
  }
  subcomSource: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SOURCE))\\b'
  }
  subcomSpecification: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SPECIFICATION))\\b'
  }
  subcomSplit: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SPLIT))\\b'
  }
  subcomSQL: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SQL))\\b'
  }
  subcomSRSEstimator: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SRSESTIMATOR))\\b'
  }
  subcomStageVars: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STAGEVARS))\\b'
  }
  subcomStandardDeviation: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SD))\\b'
  }
  subcomStandardize: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STANDARDIZE))\\b'
  }
  subcomStatistics: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STATISTICS))\\b'
  }
  subcomStatus: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STATUS))\\b'
  }
  subcomStrata: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STRATA))\\b'
  }
  subcomSubPop: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUBPOP))\\b'
  }
  subcomSubTitle: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUBTITLE))\\b'
  }
  subcomSum: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUM))\\b'
  }
  subcomSummary: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUMMARY))\\b'
  }
  subcomSupplementary: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUPPLEMENTARY))\\b'
  }
  subcomTable: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TABLE))\\b'
  }
  subcomTables: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TABLES))\\b'
  }
  subcomTarget: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TARGET))\\b'
  }
  subcomTargetOptions: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TARGET_OPTIONS))\\b'
  }
  subcomTemplate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TEMPLATE))\\b'
  }
  subcomTest: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TEST))\\b'
  }
  subcomTitle: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TITLE))\\b'
  }
  subcomTitles: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TITLES))\\b'
  }
  subcomTolerance: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TOLERANCE))\\b'
  }
  subcomTotal: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TOTAL))\\b'
  }
  subcomTrailingSpaces: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TRAILINGSPACES))\\b'
  }
  subcomTransform: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TRANSFORM))\\b'
  }
  subcomType: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TYPE))\\b'
  }
  subcomUnencrypted: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(UNENCRYPTED))\\b'
  }
  subcomUnselected: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(UNSELECTED))\\b'
  }
  subcomUpperBound: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(UPPERBOUND))\\b'
  }
  subcomVariables: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VARIABLES))\\b'
  }
  subcomVarInfo: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VARINFO))\\b'
  }
  subcomView: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VIEW))\\b'
  }
  subcomVIN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VIN))\\b'
  }
  subcomVLabels: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VLABELS))\\b'
  }
  subcomWeight: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(WEIGHT))\\b'
  }
  subcomWild: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(WILD))\\b'
  }
  subcomWrite: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(WRITE))\\b'
  }
  subcomWSDesign: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(WSDESIGN))\\b'
  }
  subcomWSFactor: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(WSFACTOR))\\b'
  }

  # Add highlighting for other system variables. We have $SYSMIS here but there are others.
  # Use scope invalid.deprecated for deprecated commands.
  # Subcommand keywords in commands is inconsistent right now. Need to revise this later.
  #     Use scope support.constant for keywords that are predefined values.
  #     Use scope keyword.other for keywords that take parameters (parentheses or otherwise).
  # Check for deprecated commands (docu and elsewhere).
