scopeName: 'source.spss'
name: 'SPSS'
fileTypes: [ 'sps' ]
limitLineLength: false
firstLineMatch: '^(?:\\* Encoding: UTF-8)'
patterns: [
  { include: '#metaMultilineComments' }
  { include: '#metaCommandFriendlyComments' }
  { include: '#metaQuoteStrings' }
  { include: '#metaCommands' }
  { include: '#metaConditionals' }
  {
    name: 'keyword.keyword.spss'
    match: '\\b(?i:(BIPLOT|CENTR|DENOMINATOR|LOADING|NUMERATOR))\\b'
  }
  { include: '#metaOperators' }
  { include: '#metaConstants' }
  { include: '#metaPunctuation' }
]

repository:
  # Meta groups, referenced in main patterns[]
  metaMultilineComments: {
    comment: 'These are the multiline comment types. They cannot go inside a command.'
    patterns: [
      { include: '#multilineCommentAsterisk' }
      { include: '#multilineCommentCommand' }
    ]
  }
  metaCommandFriendlyComments: {
    comment: 'These comment types can be used within a command. Comments on their own line inside a command cause an error (blank line as terminator).'
    patterns: [
      { include: '#inlineComment' }
      { include: '#lineComment' }
    ]
  }
  metaQuoteStrings: {
    comment: 'Includes both single and double quote strings. SPSS does not support other string types.'
    patterns: [
      { include: '#singleQuoteString' }
      { include: '#doubleQuoteString' }
    ]
  }
  metaConditionals: {
    comment: 'Includes all conditionals for flow control (e.g. if, else).'
    patterns: [
      { include: '#controlConditionals' }
    ]
  }
  metaOperators: {
    comment: 'Includes all operators, in written form (e.g. EQ) or symbolic (e.g. =).'
    patterns: [
      { include: '#operatorsNumeric' }
      { include: '#operatorsLogical' }
      { include: '#operatorsLogicalSymbolic' }
      { include: '#operatorsRelational' }
      { include: '#operatorsRelationalSymbolic' }
      { include: '#operatorsArithmetic' }
    ]
  }
  metaConstants: {
    comment: 'Includes constants provided by SPSS.'
    patterns: [
      { include: '#plainLanguageConstants' }
    ]
  }
  metaPunctuation: {
    comment: 'Includes punctuation, i.e. brackets.'
    patterns: [
      { include: '#punctuationForArray' }
      { include: '#punctuationForFunction' }
    ]
  }
  metaCommands: {
    comment: 'Includes commands provided by SPSS.'
    patterns: [
      { include: '#simpleCommands' }
      { include: '#twoStageLeastSquares' }
      { include: '#autocorrelationFunction' }
      { include: '#addFiles' }
      { include: '#automatedDataPreparation' }
      { include: '#aggregateCommand' }
      { include: '#aimCommand' }
      { include: '#alscalCommand' }
      { include: '#alterType' }
      { include: '#anacorCommand' }
      { include: '#analysisOfVariance' }
      { include: '#applyDictionary' }
      { include: '#aregCommand' }
      { include: '#arimaCommand' }
      { include: '#autoRecode' }
      { include: '#bayesANOVA' }
      { include: '#bayesCorrelation' }
      { include: '#bayesIndependent' }
      { include: '#bayesLogLinear' }
      { include: '#bayesOneSample' }
      { include: '#bayesRegression' }
      { include: '#bayesRelated' }
      { include: '#bayesRepeated' }
      { include: '#beginData' }
      { include: '#beginExpr' }
      { include: '#simprepBegin' }
      { include: '#beginGPL' }
      { include: '#beginProgram' }
      { include: '#bootStrap' }
      { include: '#casePlot' }
      { include: '#casesToVars' }
      { include: '#catpcaCommand' }
      { include: '#catregCommand' }
      { include: '#ccfCommand' }
      { include: '#clusterCommand' }
      { include: '#codeBook' }
      { include: '#compareDatasets' }
      { include: '#conjointCommand' }
      { include: '#correlationsCommand' }
      { include: '#correspondenceCommand' }
      { include: '#coxregCommand' }
      { include: '#createCommand' }
      { include: '#crossTabulation' }
      { include: '#csCoxReg' }
      { include: '#csDescriptives' }
      { include: '#csGLM' }
      { include: '#csLogistic' }
      { include: '#csOrdinal' }
      { include: '#csPlan' }
      { include: '#csSelect' }
      { include: '#csTabulate' }
      { include: '#customTables' }
      { include: '#curveFit' }
      { include: '#dataList' }
      { include: '#datafileAttribute' }
      { include: '#datasetActivate' }
      { include: '#datasetCopy' }
      { include: '#datasetDeclare' }
      { include: '#datasetName' }
      { include: '#dateCommand' }
      { include: '#defineEndDefine' }
    ]
  }

  # Meta groups for command formatting:
  metaCommandFormatting: {
    comment: 'Everything that is formated in a command block, except the command word itself, subcommands, and command/subcom-specific keywords.'
    patterns: [
      { include: '#metaCommandFriendlyComments' }
      { include: '#metaQuoteStrings' }
      { include: '#metaConditionals' }
      { include: '#metaOperators' }
      { include: '#metaConstants' }
      { include: '#metaPunctuation' }
      { include: '#commandBodyText' }
    ]
  }

  # Comments
  multilineCommentAsterisk: {
    comment: 'Identify multi-line comments beginning with an asterisk and ending with a period'
    name: 'comment.block.asterisk.spss'
    begin: '(^\\*)'
    beginCaptures:
      1: name: 'punctuation.definition.comment.spss'
    end: '(\\.\\s*$)'
    endCaptures:
      0: name: 'punctuation.definition.comment.spss'
  }
  multilineCommentCommand: {
    name: 'comment.block.comment.spss'
    begin: '^(?i:COMMENT)'
    beginCaptures:
      1: name: 'punctuation.definition.comment.spss'
    end: '(\\.\\s*$)'
    endCaptures:
      0: name: 'punctuation.definition.comment.spss'
  }
  inlineComment: {
    comment: 'Identify inline comments beginning with `/*` and ending with `*/`'
    name: 'comment.line.spss'
    match: '(\\/\\*)(.*)(\\*\\/)'
  }
  lineComment: {
    comment: 'Identify single-line comments beginning with `/*`'
    name: 'comment.line.spss'
    match: '\\/\\*.*$'
  }

  # Quote strings:
  singleQuoteString: {
    name: 'string.quoted.single.spss'
    begin: '\''
    end: '\''
  }
  doubleQuoteString: {
    name: 'string.quoted.double.spss'
    begin: '"'
    end: '"'
  }

  # Global keywords & operators:
  controlConditionals: {
    name: 'keyword.control.conditionals.spss'
    match: '\\b(?i:(IF|THEN|ELSE|WHILE|FOR|DO|END|REPEAT|BY|WITH|ALL|TO|BREAK))\\b'
  }
  operatorsNumeric: {
    name: 'keyword.operator.numeric.spss'
    match: '\\b(?i:(LOWEST|LO|HIGHEST|HI|THRU|MISSING|SYSMIS))\\b'
  }
  operatorsLogical: {
    name: 'keyword.operator.logical.spss'
    match: '\\b(?i:(AND|OR|NOT))\\b'
  }
  operatorsLogicalSymbolic: {
    name: 'keyword.operator.logical.symbolic.spss'
    match: '\\&|\\|'
  }
  operatorsRelational: {
    name: 'keyword.operator.relational.spss'
    match: '\\b(?i:(EQ|NE|LT|LE|GT|GE))\\b'
  }
  operatorsRelationalSymbolic: {
    name: 'keyword.operator.relational.symbolic.spss'
    match: '=|<>|<|>|<=|>=|~=|Â¬='
  }
  operatorsArithmetic: {
    name: 'keyword.operator.arithmetic.spss'
    match: '\\+|\\-|\\*|/|\\*\\*'
  }

  # Constants:
  plainLanguageConstants: {
    name: 'constant.language.spss'
    match: '\\b(?i:(true|false|null))\\b'
  }

  # Bracket punctuation:
  punctuationForArray: {
    name: 'punctuation.section.array.spss'
    match: '\\[|\\]'
  }
  punctuationForFunction: {
    name: 'punctuation.section.function.spss'
    match: '\\(|\\)'
  }

  # Command body text:
  commandBodyText: {
    comment: 'The command takes up the whole code block, but we only want the command keyword and period to highlight. Also only highlight relevant subcommands and other scopes.'
    name: 'punctuation.command.body.spss'
    match: '((\\$*)(\\#*)(\\@*)\\b([0-9._\\p{L}]+)\\b)|([\\?!@#$%^\\.,;:\\\\{}`~])'
  }

  # Commands:
  simpleCommands: {
    comment: 'Commands with no subcommands or special keywords.'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADD DOCUMENT|ADD VALUE LABELS|CACHE|CD|CLEAR TIME PROGRAM
      |CLEAR TRANSFORMATIONS|COMPUTE|COUNT|DATASET CLOSE|DATASET DISPLAY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  twoStageLeastSquares: {
    comment: '2SLS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(2SLS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to 2SLS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(EQUATION|INSTRUMENTS|ENDOGENOUS))\\b'
      }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomSave' }
      { include: '#subcomPrint' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for 2SLS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PRED|RESSID|COV))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  autocorrelationFunction: {
    comment: 'ACF Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ACF))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ACF.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SERROR|PACF))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomSeasonal' }
      { include: '#subcomMXAuto' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for ACF.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(IND|MA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  addFiles: {
    comment: 'ADD FILES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADD FILES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomRename' }
      { include: '#subcomDrop' }
      { include: '#subcomKeep' }
      { include: '#subcomIn' }
      { include: '#subcomFirst' }
      { include: '#subcomLast' }
      { include: '#subcomMap' }
      {
        comment: 'Valid keywords for ADD FILES.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  automatedDataPreparation: {
    comment: 'ADP Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADP))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ADP.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PREPDATETIME|ADJUSTLEVEL|OUTLIERHANDLING|REPLACEMISSING|REORDERNOMINAL))\\b'
      }
      { include: '#subcomFields' }
      { include: '#subcomScreening' }
      { include: '#subcomRescale' }
      { include: '#subcomTransform' }
      { include: '#subcomCriteria' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for ADP.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(TARGET|INPUT|ANALYSISWEIGHT|(DATE|TIME)DURATION
          |EXTRACT(YEAR|MONTH|DAY|HOUR|MINUTE|SECOND)|SUFFIX|PCTMISSING|(UNIQUE|SINGLE)CAT
          |MAXVALORDINAL|MINVALCONTINUOUS|CUTOFF|REPLACEWITH|MERGESUPERVISED|MERGEUNSUPERVISED
          |BINNING|SELECTION|CONSTRUCTION))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aggregateCommand: {
    comment: 'AGGREGATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AGGREGATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AGGREGATE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(DOCUMENT|PRESORTED))\\b'
      }
      { include: '#subcomOutfile' }
      { include: '#subcomBreak' }
      { include: '#subcomMissing' }
      { include: '#subcomSum' }
      { include: '#subcomMean' }
      { include: '#subcomMedian' }
      { include: '#subcomStandardDeviation' }
      { include: '#subcomMax' }
      { include: '#subcomMin' }
      { include: '#subcomPGT' }
      { include: '#subcomPLT' }
      { include: '#subcomPIN' }
      { include: '#subcomPOUT' }
      { include: '#subcomFGT' }
      { include: '#subcomFLT' }
      { include: '#subcomFIN' }
      { include: '#subcomFOUT' }
      { include: '#subcomN' }
      { include: '#subcomNU' }
      { include: '#subcomNMiss' }
      { include: '#subcomNUMiss' }
      { include: '#subcomFirst' }
      { include: '#subcomLast' }
      {
        comment: 'Valid keywords for AGGREGATE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(MODE|OVERWRITE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aimCommand: {
    comment: 'AIM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AIM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCategorical' }
      { include: '#subcomContinuous' }
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for AIM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ADJUST|CI|HIDENOTSIG|SHOWREFLINE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  alscalCommand: {
    comment: 'ALSCAL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ALSCAL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ALSCAL.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(LEVEL))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomInput' }
      { include: '#subcomShape' }
      { include: '#subcomCondition' }
      { include: '#subcomFile' }
      { include: '#subcomModel' }
      { include: '#subcomCriteria' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomOutfile' }
      { include: '#subcomMatrix' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  alterType: {
    comment: 'ALTER TYPE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ALTER TYPE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPrint' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  anacorCommand: {
    comment: 'ANACOR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ANACOR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ANACOR.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(VARIANCES))\\b'
      }
      { include: '#subcomTable' }
      { include: '#subcomDimension' }
      { include: '#subcomNormalization' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMatrix' }
      {
        comment: 'Valid keywords for ANACOR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(OUT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  analysisOfVariance: {
    comment: 'ANOVA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ANOVA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ANOVA.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(COVARIATES|MAXORDERS))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomMethod' }
      { include: '#subcomStatistics' }
      { include: '#subcomMissing' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  applyDictionary: {
    comment: 'APPLY DICTIONARY Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(APPLY DICTIONARY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to APPLY DICTIONARY.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(NEWVARS))\\b'
      }
      { include: '#subcomFrom' }
      { include: '#subcomSource' }
      { include: '#subcomTarget' }
      { include: '#subcomFileInfo' }
      { include: '#subcomVarInfo' }
      {
        comment: 'Valid keywords for ANACOR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD|ATTRIBUTES|ALIGNMENT|DOCUMENTS|FILELABEL|FORMATS|LEVEL
          |MRSETS|VARSETS|WEIGHT|MISSING|ROLE|VALLABELS|WIDTH))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aregCommand: {
    comment: 'AREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(RHO|MXITER))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomMethod' }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomApply' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  arimaCommand: {
    comment: 'ARIMA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ARIMA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ARIMA.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(CINPCT|FORECAST))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomModel' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for ARIMA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(P|D|Q|SP|SD|SQ|AR|MA|SAR|SMA|REG|CON|CONSTANT|NOCONSTANT
          |NOLOG|LG10|LN|MXITER|PAREPS|SSQPCT|MXLAMB|SPECIFICATIONS|INITIAL|FIT|EXACT
          |CLS|AUTOINIT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  autoRecode: {
    comment: 'AUTORECODE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AUTORECODE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AUTORECODE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(BLANK|GROUP|SAVE TEMPLATE|APPLY TEMPLATE|DESCENDING))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomInto' }
      { include: '#subcomPrint' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesANOVA: {
    comment: 'BAYES ANOVA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES ANOVA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES ANOVA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|REGWGT|VARIABLES|ANALYSIS|COMPUTATION
          |TYPE|SHAPEPARAM|SCALEPARAM|MEANVECTOR|VMATRIX|MEANS|ERRORVAR))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesCorrelation: {
    comment: 'BAYES CORRELATION Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES CORRELATION))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      {
        comment: 'Valid keywords for BAYES CORRELATION.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|TOL|MAXITER|MCSAMPLES|POSTSAMPLES|VARIABLES
          |ANALYSIS|CVALUE|MAXPLOTS|TYPE|NULLVALUE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesIndependent: {
    comment: 'BAYES INDEPENDENT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES INDEPENDENT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES INDEPENDENT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|VARIABLES|GROUP|SELECT|DATAVAR|ANALYSIS
          |COMPUTATION|EQUALDATAVAR|VARDIST|MEANDIST))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesLogLinear: {
    comment: 'BAYES LOGLINEAR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES LOGLINEAR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomTable' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrint' }
      {
        comment: 'Valid keywords for BAYES LOGLINEAR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|TOL|MAXITER|POSTSAMPLES|ORDER|ANALYSIS|MODEL
          |FIXMARGIN|FIXMARGINS|FIX_MARGINS|PRIORTYPE|PRIOR_TYPE|SHAPEPARAMS|SCALEPARAM
          |LAMBDAS|SUPPRESSTABLE|SUPPRESS_TABLE|CELLS|STATISTICS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesOneSample: {
    comment: 'BAYES ONESAMPLE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES ONESAMPLE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomData' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES ONESAMPLE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SCOPE|CILEVEL|DISTRIBUTION|VARIABLES|ANALYSIS|SUCCESS
          |NULLPRIORPARAM|ALTERPRIORPARAM|VARDIST|PREDIST|TYPE|METHOD|SEED|TOL|MAXITER
          |MCSAMPLES|VARIANCE|NULLVALUE|ALTERGVALUE|PRECDIST|MEANDIST|KAPPA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRegression: {
    comment: 'BAYES REGRESSION Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES REGRESSION))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BAYES REGRESSION.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PREDICT|FTEST))\\b'
      }
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES REGRESSION.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|REGWGT|FACTORS|COVARIATES|ANALYSIS
          |COMPUTATION|COMPARE|TYPE|SHAPEPARAM|SCALEPARAM|MEANVECTOR|VMATRIX|REGRESSORS
          |PARAMETER|MAX_CATEGORY|INTERCEPT|ERRORVAR|BAYESPRED|LABEL|VARIABLES|TESTVALUES))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRelated: {
    comment: 'BAYES RELATED Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES RELATED))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BAYES RELATED.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PAIR))\\b'
      }
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES RELATED.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SCOPE|CILEVEL|METHOD|SEED|TOL|MAXITER|MCSAMPLES|ANALYSIS
          |VARIABLES|VARIANCE|NULLVALUE|ALTERGVALUE|VARDIST|PRECDIST|MEANDIST|KAPPA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRepeated: {
    comment: 'BAYES REPEATED Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES REPEATED))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES REPEATED.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|MCSAMPLES|REGWGT|ANALYSIS|COMPUTATION|MEANS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginData: {
    comment: 'BEGIN DATA-END DATA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN DATA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END DATA))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginExpr: {
    comment: 'BEGIN EXPR-END EXPR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN EXPR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END EXPR))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  simprepBegin: {
    comment: 'SIMPREP BEGIN-SIMPREP END Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(SIMPREP BEGIN))\\b'
    beginCaptures:
      1: name: 'invalid.deprecated.command.spss'
    end: '\\b(?i:(SIMPREP END))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'invalid.deprecated.command.end.spss'
    patterns: [
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginGPL: {
    comment: 'BEGIN GPL-END GPL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN GPL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END GPL))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for BEGIN GPL-END GPL.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SOURCE|DATA|SCALE|GUIDE|ELEMENT|COORD|PAGE|GRAPH|COMMENT|TRANS))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginProgram: {
    comment: 'BEGIN PROGRAM-END PROGRAM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN PROGRAM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END PROGRAM))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for BEGIN PROGRAM-END PROGRAM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PYTHON3))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bootStrap: {
    comment: 'BOOTSTRAP Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BOOTSTRAP))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BOOTSTRAP.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SAMPLING))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for BOOTSTRAP.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SIMPLE|STRATIFIED|RESIDUAL|WILD|TARGET|INPUT|CILEVEL|CITYPE
          |NSAMPLES|USERMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  casePlot: {
    comment: 'CASEPLOT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CASEPLOT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomID' }
      { include: '#subcomFormat' }
      { include: '#subcomMark' }
      { include: '#subcomSplit' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for CASEPLOT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(REFERENCE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  casesToVars: {
    comment: 'CASESTOVARS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CASESTOVARS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CASESTOVARS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(VIND|AUTOFIX|SEPARATOR|GROUPBY))\\b'
      }
      { include: '#subcomID' }
      { include: '#subcomIndex' }
      { include: '#subcomCount' }
      { include: '#subcomFixed' }
      { include: '#subcomRename' }
      { include: '#subcomDrop' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  catpcaCommand: {
    comment: 'CATPCA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CATPCA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomAnalysis' }
      { include: '#subcomDiscretization' }
      { include: '#subcomMissing' }
      { include: '#subcomSupplementary' }
      { include: '#subcomConfiguration' }
      { include: '#subcomDimension' }
      { include: '#subcomNormalization' }
      { include: '#subcomMaxIter' }
      { include: '#subcomCritIter' }
      { include: '#subcomRotation' }
      { include: '#subcomResample' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CATPCA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WEIGHT|LEVEL|BOOTSTRAP|OBJECT|CATEGORY|LOADING|TRANS|RESID
          |BIPLOT|TRIPLOT|JOINTCAT|PROJCENTR|VAF|LDELLAREA|OBELLAREA|CTELLAREA|NELLPNT
          |NONE|NDIM|CENTR|DISCRDATA|TRDATA|APPROX|ELLCOORD))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  catregCommand: {
    comment: 'CATREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CATREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CATREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(REGULARIZATION))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomAnalysis' }
      { include: '#subcomDiscretization' }
      { include: '#subcomMissing' }
      { include: '#subcomSupplementary' }
      { include: '#subcomInitial' }
      { include: '#subcomMaxIter' }
      { include: '#subcomCritIter' }
      { include: '#subcomResample' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CATREG.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(LEVEL|OBJECT|NONE|RIDGE|LASSO|ENET|CROSSVAL|BOOTSTRAP
          |TRANS|RESID|REGU|DISCRDATA|TRDATA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  ccfCommand: {
    comment: 'CCF Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CCF))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CCF.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(MXCROSS))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomSeasonal' }
      { include: '#subcomApply' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  clusterCommand: {
    comment: 'CLUSTER Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CLUSTER))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMeasure' }
      { include: '#subcomMethod' }
      { include: '#subcomSave' }
      { include: '#subcomID' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMissing' }
      { include: '#subcomMatrix' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  codeBook: {
    comment: 'CODEBOOK Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CODEBOOK))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVarInfo' }
      { include: '#subcomFileInfo' }
      { include: '#subcomStatistics' }
      { include: '#subcomOptions' }
      {
        comment: 'Valid keywords for CODEBOOK.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(MAXCATS|VARORDER|SORT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  compareDatasets: {
    comment: 'COMPARE DATASETS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(COMPARE DATASETS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to COMPARE DATASETS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(COMPDATASET|CASEID))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomSave' }
      { include: '#subcomOutput' }
      {
        comment: 'Valid keywords for COMPARE DATASETS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD|FLAGMISMATCHES|MATCHDATASET|MISMATCHDATASET
          |ENCRYPTEDPW|VARPROPERTIES|CASETABLE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  conjointCommand: {
    comment: 'CONJOINT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CONJOINT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CONJOINT.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SEQUENCE|RANK|SCORE|SUBJECT|UTILITY))\\b'
      }
      { include: '#subcomPlan' }
      { include: '#subcomData' }
      { include: '#subcomFactors' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  correlationsCommand: {
    comment: 'CORRELATIONS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CORRELATIONS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomPrint' }
      { include: '#subcomStatistics' }
      { include: '#subcomMissing' }
      { include: '#subcomMatrix' }
      { include: '#subcomCI' }
      {
        comment: 'Valid keywords for CORRELATIONS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(METHOD|BIAS|CILEVEL))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  correspondenceCommand: {
    comment: 'CORRESPONDENCE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CORRESPONDENCE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CORRESPONDENCE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(EQUAL))\\b'
      }
      { include: '#subcomTable' }
      { include: '#subcomDimension' }
      { include: '#subcomSupplementary' }
      { include: '#subcomMeasure' }
      { include: '#subcomStandardize' }
      { include: '#subcomNormalization' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  coxregCommand: {
    comment: 'COXREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(COXREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomStatus' }
      { include: '#subcomStrata' }
      { include: '#subcomCategorical' }
      { include: '#subcomContrast' }
      { include: '#subcomMethod' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomCriteria' }
      { include: '#subcomPlot' }
      { include: '#subcomPattern' }
      { include: '#subcomOutfile' }
      { include: '#subcomSave' }
      { include: '#subcomExternal' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  createCommand: {
    comment: 'CREATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CREATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CREATE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(CSUM|FFT|IFFT|LAG|LEAD|PMA|RMED|T4253H))\\b'
      }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomMA' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }
  crossTabulation: {
    comment: 'CROSSTABS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CROSSTABS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CROSSTABS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SHOWDIM))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomTables' }
      { include: '#subcomCells' }
      { include: '#subcomStatistics' }
      { include: '#subcomMethod' }
      { include: '#subcomMissing' }
      { include: '#subcomFormat' }
      { include: '#subcomCount' }
      { include: '#subcomBarChart' }
      { include: '#subcomWrite' }
      { include: '#subcomHideSmallCounts' }
      {
        comment: 'Valid keywords for CROSSTABS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(COUNT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csCoxReg: {
    comment: 'CSCOXREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSCOXREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CSCOXREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(TESTASSUMPTIONS|SURVIVALMETHOD))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomCustom' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomPlot' }
      { include: '#subcomPattern' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSCOXREG.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(STATUS|BASELINESTRATA|FILE|CILEVEL|DF|LCONVERGE|MXITER
          |MXSTEP|PCONVERGE|SINGULAR|TIES|TYPE|PADJUST|PROPHAZARD|PARAMETER|COVB
          |BASELINE|CI|CORB|SURVIVAL|LABEL|LMATRIX|KMATRIX|CLASSMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csDescriptives: {
    comment: 'CSDESCRIPTIVES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSDESCRIPTIVES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CSDESCRIPTIVES.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(RATIO))\\b'
      }
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomSummary' }
      { include: '#subcomMean' }
      { include: '#subcomSum' }
      { include: '#subcomStatistics' }
      { include: '#subcomSubPop' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for CSDESCRIPTIVES.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|VARIABLES|TTEST|VALUE|VALUELIST|DISPLAY|SCOPE|CLASSMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csGLM: {
    comment: 'CSGLM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSGLM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomIntercept' }
      { include: '#subcomCustom' }
      { include: '#subcomEMMeans' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSGLM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|INCLUDE|SHOW|TABLES|OTHER|CONTRAST|COMPARE|CILEVEL|DF
          |SINGULAR|TYPE|PADJUST|CLASSMISSING|COVB|CORB|PARAMETER|LABEL|LMATRIX|KMATRIX))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csLogistic: {
    comment: 'CSLOGISTIC Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSLOGISTIC))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomIntercept' }
      { include: '#subcomCustom' }
      { include: '#subcomOddsRatios' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSLOGISTIC.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|INCLUDE|SHOW|LABEL|FACTOR|COVARIATE|CONTROL|CHKSEP
          |CILEVEL|DF|LCONVERGE|MXITER|MXSTEP|PCONVERGE|SINGULAR|TYPE|PADJUST|VARIABLE
          |CLASSMISSING|COVB|CORB|PARAMETER|LMATRIX|KMATRIX))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csOrdinal: {
    comment: 'CSORDINAL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSORDINAL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomModel' }
      { include: '#subcomLink' }
      { include: '#subcomCustom' }
      { include: '#subcomOddsRatios' }
      { include: '#subcomCriteria' }
      { include: '#subcomStatistics' }
      { include: '#subcomNonParallel' }
      { include: '#subcomTest' }
      { include: '#subcomDomain' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CSORDINAL.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|FUNCTION|LABEL|LMATRIX|KMATRIX|FACTOR|COVARIATE|CONTROL
          |CHKSEP|CILEVEL|DF|LCONVERGE|METHOD|MXITER|MXSTEP|PCONVERGE|SINGULAR|TYPE
          |PADJUST|CLASSMISSING|COVB|CORB|PARAMETER))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csPlan: {
    comment: 'CSPLAN Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSPLAN))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomPlanVars' }
      { include: '#subcomSRSEstimator' }
      { include: '#subcomPrint' }
      { include: '#subcomDesign' }
      { include: '#subcomMethod' }
      { include: '#subcomSize' }
      { include: '#subcomRate' }
      { include: '#subcomMOS' }
      { include: '#subcomStageVars' }
      { include: '#subcomEstimator' }
      { include: '#subcomPopSize' }
      { include: '#subcomInclProb' }
      {
        comment: 'Valid keywords for CSPLAN.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|ANALYSISWEIGHT|SAMPLEWEIGHT|PREVIOUSWEIGHT|STAGELABEL
          |STRATA|CLUSTER|ESTIMATION|VALUE|MATRIX|VARIABLE|MINSIZE|MAXSIZE|SOURCE
          |MIN|MAX))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csSelect: {
    comment: 'CSSELECT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSSELECT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomCriteria' }
      { include: '#subcomClassMissing' }
      { include: '#subcomData' }
      { include: '#subcomSampleFile' }
      { include: '#subcomJointProb' }
      { include: '#subcomSelectRule' }
      { include: '#subcomPrint' }
      {
        comment: 'Valid keywords for CSSELECT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|STAGES|SEED|RENAMEVARS|PRESORTED|OUTFILE|KEEP|DROP))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  csTabulate: {
    comment: 'CSTABULATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CSTABULATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPlan' }
      { include: '#subcomJointProb' }
      { include: '#subcomTables' }
      { include: '#subcomCells' }
      { include: '#subcomStatistics' }
      { include: '#subcomTest' }
      { include: '#subcomSubPop' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for CSTABULATE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FILE|VARIABLES|DISPLAY|SCOPE|CLASSMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  customTables: {
    comment: 'CTABLES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CTABLES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomTable' }
      { include: '#subcomSLabels' }
      { include: '#subcomCLabels' }
      { include: '#subcomCategories' }
      { include: '#subcomCriteria' }
      { include: '#subcomTitles' }
      { include: '#subcomFormat' }
      { include: '#subcomVLabels' }
      { include: '#subcomSMissing' }
      { include: '#subcomMRSets' }
      { include: '#subcomWeight' }
      { include: '#subcomPCompute' }
      { include: '#subcomPProperties' }
      { include: '#subcomHideSmallCounts' }
      {
        comment: 'Valid keywords for CTABLES.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(POSITION|VISIBLE|ROWLABELS|COLLABELS|MISSING|OTHERNM|SUBTOTAL
          |HSUBTOTAL|ORDER|KEY|TOTAL|LABEL|EMPTY|CILEVEL|CAPTION|CORNER|TITLE|TYPE
          |ALPHA|INCLUDEMRSETS|ADJUST|MEANSVARIANCE|MERGE|STYLE|SHOWSIG|ORIGIN
          |MINCOLWIDTH|MAXCOLWIDTH|UNITS|VARIABLES|DISPLAY|COUNTDUPLICATES|FORMAT
          |HIDESOURCECATS|COUNT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  curveFit: {
    comment: 'CURVEFIT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CURVEFIT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomModel' }
      { include: '#subcomUpperBound' }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomCIN' }
      { include: '#subcomPlot' }
      { include: '#subcomID' }
      { include: '#subcomSave' }
      { include: '#subcomPrint' }
      { include: '#subcomApply' }
      { include: '#subcomTemplate' }
      {
        comment: 'Valid keywords for CURVEFIT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ANOVA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  dataList: {
    comment: 'DATA LIST Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATA LIST))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomEncoding' }
      { include: '#subcomTable' }
      { include: '#subcomNoTable' }
      { include: '#subcomRecords' }
      { include: '#subcomSkip' }
      {
        comment: 'Valid keywords for DATA LIST.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(FIXED|FREE|LIST))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datafileAttribute: {
    comment: 'DATAFILE ATTRIBUTE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATAFILE ATTRIBUTE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATAFILE ATTRIBUTE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ATTRIBUTE|DELETE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetActivate: {
    comment: 'DATASET ACTIVATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET ACTIVATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET ACTIVATE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetCopy: {
    comment: 'DATASET COPY Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET COPY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET COPY.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetDeclare: {
    comment: 'DATASET DECLARE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET DECLARE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET DECLARE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  datasetName: {
    comment: 'DATASET NAME Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET NAME))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET NAME.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WINDOW))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  dateCommand: {
    comment: 'DATASET NAME Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DATASET NAME))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for DATASET NAME.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(YEAR|QUARTER|MONTH|WEEK|DAY|HOUR|MINUTE|SECOND|CYCLE|OBS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  defineEndDefine: {
    comment: 'DEFINE-!ENDDEFINE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(DEFINE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(!)\\b(?i:(ENDDEFINE))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMPrint' }
      { include: '#subcomMExpand' }
      { include: '#subcomMNest' }
      { include: '#subcomMIterate' }
      {
        comment: 'Valid keywords for BEGIN PROGRAM-END PROGRAM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PRESERVE|RESTORE))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  # Common subcommands:
  subcomAnalysis: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ANALYSIS))\\b'
  }
  subcomApply: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(APPLY))\\b'
  }
  subcomBarChart: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(BARCHART))\\b'
  }
  subcomBreak: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(BREAK))\\b'
  }
  subcomCategorical: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CATEGORICAL))\\b'
  }
  subcomCategories: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CATEGORIES))\\b'
  }
  subcomCells: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CELLS))\\b'
  }
  subcomCI: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CI))\\b'
  }
  subcomCIN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CIN))\\b'
  }
  subcomCLabels: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CLABELS))\\b'
  }
  subcomClassMissing: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CLASSMISSING))\\b'
  }
  subcomCondition: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONDITION))\\b'
  }
  subcomConfiguration: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONFIGURATION))\\b'
  }
  subcomConstant: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONSTANT))\\b'
  }
  subcomContinuous: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONTINUOUS))\\b'
  }
  subcomContrast: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONTRAST))\\b'
  }
  subcomCount: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(COUNT))\\b'
  }
  subcomCriteria: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CRITERIA))\\b'
  }
  subcomCritIter: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CRITITER))\\b'
  }
  subcomCustom: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CUSTOM))\\b'
  }
  subcomData: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DATA))\\b'
  }
  subcomDesign: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DESIGN))\\b'
  }
  subcomDiff: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIFF))\\b'
  }
  subcomDimension: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIMENSION))\\b'
  }
  subcomDiscretization: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DISCRETIZATION))\\b'
  }
  subcomDomain: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DOMAIN))\\b'
  }
  subcomDrop: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DROP))\\b'
  }
  subcomEMMeans: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(EMMEANS))\\b'
  }
  subcomEncoding: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ENCODING))\\b'
  }
  subcomESTBF: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ESTBF))\\b'
  }
  subcomEstimator: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ESTIMATOR))\\b'
  }
  subcomExternal: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(EXTERNAL))\\b'
  }
  subcomFactors: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FACTORS))\\b'
  }
  subcomFGT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FGT))\\b'
  }
  subcomFields: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIELDS))\\b'
  }
  subcomFile: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FILE))\\b'
  }
  subcomFileInfo: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FILEINFO))\\b'
  }
  subcomFIN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIN))\\b'
  }
  subcomFirst: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIRST))\\b'
  }
  subcomFixed: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIXED))\\b'
  }
  subcomFLT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FLT))\\b'
  }
  subcomFormat: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FORMAT))\\b'
  }
  subcomFOUT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FOUT))\\b'
  }
  subcomFrom: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FROM))\\b'
  }
  subcomHideSmallCounts: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(HIDESMALLCOUNTS))\\b'
  }
  subcomID: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ID))\\b'
  }
  subcomIn: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(IN))\\b'
  }
  subcomInclProb: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INCLPROB))\\b'
  }
  subcomIndex: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INDEX))\\b'
  }
  subcomInference: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INFERENCE))\\b'
  }
  subcomInitial: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INITIAL))\\b'
  }
  subcomInput: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INPUT))\\b'
  }
  subcomIntercept: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INTERCEPT))\\b'
  }
  subcomInto: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INTO))\\b'
  }
  subcomJointProb: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(JOINTPROB))\\b'
  }
  subcomKeep: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(KEEP))\\b'
  }
  subcomLast: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LAST))\\b'
  }
  subcomLink: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LINK))\\b'
  }
  subcomMA: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MA))\\b'
  }
  subcomMap: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAP))\\b'
  }
  subcomMark: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MARK))\\b'
  }
  subcomMatrix: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MATRIX))\\b'
  }
  subcomMax: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAX))\\b'
  }
  subcomMaxIter: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAXITER))\\b'
  }
  subcomMean: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEAN))\\b'
  }
  subcomMeasure: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEASURE))\\b'
  }
  subcomMedian: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEDIAN))\\b'
  }
  subcomMethod: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(METHOD))\\b'
  }
  subcomMExpand: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEXPAND))\\b'
  }
  subcomMin: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MIN))\\b'
  }
  subcomMissing: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MISSING))\\b'
  }
  subcomMIterate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MITERATE))\\b'
  }
  subcomMNest: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MNEST))\\b'
  }
  subcomModel: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MODEL))\\b'
  }
  subcomMOS: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MOS))\\b'
  }
  subcomMPrint: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MPRINT))\\b'
  }
  subcomMRSets: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MRSETS))\\b'
  }
  subcomMXAuto: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MXAUTO))\\b'
  }
  subcomN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(N))\\b'
  }
  subcomNU: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NU))\\b'
  }
  subcomNaturalLogarithm: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LN))\\b'
  }
  subcomNMiss: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NMISS))\\b'
  }
  subcomNUMiss: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NUMISS))\\b'
  }
  subcomNoConstant: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOCONSTANT))\\b'
  }
  subcomNoLog: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOLOG))\\b'
  }
  subcomNonParallel: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NONPARALLEL))\\b'
  }
  subcomNormalization: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NORMALIZATION))\\b'
  }
  subcomNoTable: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOTABLE))\\b'
  }
  subcomOddsRatios: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ODDSRATIOS))\\b'
  }
  subcomOptions: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OPTIONS))\\b'
  }
  subcomOutfile: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OUTFILE))\\b'
  }
  subcomOutput: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OUTPUT))\\b'
  }
  subcomPattern: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PATTERN))\\b'
  }
  subcomPCompute: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PCOMPUTE))\\b'
  }
  subcomPeriod: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PERIOD))\\b'
  }
  subcomPGT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PGT))\\b'
  }
  subcomPIN: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PIN))\\b'
  }
  subcomPlan: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLAN))\\b'
  }
  subcomPlanVars: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLANVARS))\\b'
  }
  subcomPLT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLT))\\b'
  }
  subcomPlot: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLOT))\\b'
  }
  subcomPopSize: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(POPSIZE))\\b'
  }
  subcomPOUT: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(POUT))\\b'
  }
  subcomPProperties: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PPROPERTIES))\\b'
  }
  subcomPrint: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PRINT))\\b'
  }
  subcomPrior: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PRIOR))\\b'
  }
  subcomRate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RATE))\\b'
  }
  subcomRecords: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RECORDS))\\b'
  }
  subcomRename: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RENAME))\\b'
  }
  subcomResample: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RESAMPLE))\\b'
  }
  subcomRescale: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RESCALE))\\b'
  }
  subcomRotation: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ROTATION))\\b'
  }
  subcomSampleFile: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SAMPLEFILE))\\b'
  }
  subcomSave: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SAVE))\\b'
  }
  subcomScreening: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SCREENING))\\b'
  }
  subcomSDiff: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SDIFF))\\b'
  }
  subcomSeasonal: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SEASONAL))\\b'
  }
  subcomSelectRule: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SELECTRULE))\\b'
  }
  subcomShape: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SHAPE))\\b'
  }
  subcomSize: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SIZE))\\b'
  }
  subcomSkip: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SKIP))\\b'
  }
  subcomSLabels: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SLABELS))\\b'
  }
  subcomSMissing: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SMISSING))\\b'
  }
  subcomSource: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SOURCE))\\b'
  }
  subcomSplit: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SPLIT))\\b'
  }
  subcomSRSEstimator: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SRSESTIMATOR))\\b'
  }
  subcomStageVars: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STAGEVARS))\\b'
  }
  subcomStandardDeviation: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SD))\\b'
  }
  subcomStandardize: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STANDARDIZE))\\b'
  }
  subcomStatistics: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STATISTICS))\\b'
  }
  subcomStatus: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STATUS))\\b'
  }
  subcomStrata: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STRATA))\\b'
  }
  subcomSubPop: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUBPOP))\\b'
  }
  subcomSum: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUM))\\b'
  }
  subcomSummary: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUMMARY))\\b'
  }
  subcomSupplementary: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUPPLEMENTARY))\\b'
  }
  subcomTable: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TABLE))\\b'
  }
  subcomTables: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TABLES))\\b'
  }
  subcomTarget: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TARGET))\\b'
  }
  subcomTemplate: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TEMPLATE))\\b'
  }
  subcomTest: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TEST))\\b'
  }
  subcomTitles: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TITLES))\\b'
  }
  subcomTransform: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TRANSFORM))\\b'
  }
  subcomUpperBound: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(UPPERBOUND))\\b'
  }
  subcomVariables: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VARIABLES))\\b'
  }
  subcomVarInfo: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VARINFO))\\b'
  }
  subcomVLabels: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VLABELS))\\b'
  }
  subcomWeight: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(WEIGHT))\\b'
  }
  subcomWrite: {
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(WRITE))\\b'
  }

  # Add highlighting for other system variables. We have $SYSMIS here but there are others
  # Use scope invalid.deprecated for deprecated commands
  # Subcommand keywords in commands is inconsistent right now. Need to revise this later.
