scopeName: 'source.spss'
name: 'SPSS'
fileTypes: [ 'sps' ]
limitLineLength: false
firstLineMatch: '^(?:\\* Encoding: UTF-8)'
patterns: [
  { include: '#metaMultilineComments' }
  { include: '#metaCommandFriendlyComments' }
  { include: '#metaQuoteStrings' }
  { include: '#metaCommands' }
  { include: '#metaConditionals' }
  {
    name: 'keyword.keyword.spss'
    match: '\\b(?i:(BIPLOT|CENTR|DENOMINATOR|LOADING|NUMERATOR))\\b'
  }
  { include: '#metaOperators' }
  { include: '#metaConstants' }
  { include: '#metaPunctuation' }
]

repository:
  # Meta groups, referenced in main patterns[]
  metaMultilineComments: {
    comment: 'These are the multiline comment types. They cannot go inside a command.'
    patterns: [
      { include: '#multilineCommentAsterisk' }
      { include: '#multilineCommentCommand' }
    ]
  }
  metaCommandFriendlyComments: {
    comment: 'These comment types can be used within a command. Comments on their own line inside a command cause an error (blank line as terminator).'
    patterns: [
      { include: '#inlineComment' }
      { include: '#lineComment' }
    ]
  }
  metaQuoteStrings: {
    comment: 'Includes both single and double quote strings. SPSS does not support other string types.'
    patterns: [
      { include: '#singleQuoteString' }
      { include: '#doubleQuoteString' }
    ]
  }
  metaConditionals: {
    comment: 'Includes all conditionals for flow control (e.g. if, else).'
    patterns: [
      { include: '#controlConditionals' }
    ]
  }
  metaOperators: {
    comment: 'Includes all operators, in written form (e.g. EQ) or symbolic (e.g. =).'
    patterns: [
      { include: '#operatorsNumeric' }
      { include: '#operatorsLogical' }
      { include: '#operatorsLogicalSymbolic' }
      { include: '#operatorsRelational' }
      { include: '#operatorsRelationalSymbolic' }
      { include: '#operatorsArithmetic' }
    ]
  }
  metaConstants: {
    comment: 'Includes constants provided by SPSS.'
    patterns: [
      { include: '#plainLanguageConstants' }
    ]
  }
  metaPunctuation: {
    comment: 'Includes punctuation, i.e. brackets.'
    patterns: [
      { include: '#punctuationForArray' }
      { include: '#punctuationForFunction' }
    ]
  }
  metaCommands: {
    comment: 'Includes commands provided by SPSS.'
    patterns: [
      { include: '#simpleCommands' }
      { include: '#twoStageLeastSquares' }
      { include: '#autocorrelationFunction' }
      { include: '#addFiles' }
      { include: '#automatedDataPreparation' }
      { include: '#aggregateCommand' }
      { include: '#aimCommand' }
      { include: '#alscalCommand' }
      { include: '#alterType' }
      { include: '#anacorCommand' }
      { include: '#analysisOfVariance' }
      { include: '#applyDictionary' }
      { include: '#aregCommand' }
      { include: '#arimaCommand' }
      { include: '#autoRecode' }
      { include: '#bayesANOVA' }
      { include: '#bayesCorrelation' }
      { include: '#bayesIndependent' }
      { include: '#bayesLogLinear' }
      { include: '#bayesOneSample' }
      { include: '#bayesRegression' }
      { include: '#bayesRelated' }
      { include: '#bayesRepeated' }
      { include: '#beginData' }
      { include: '#beginExpr' }
      { include: '#simprepBegin' }
      { include: '#beginGPL' }
      { include: '#beginProgram' }
      { include: '#bootStrap' }
      { include: '#casePlot' }
      { include: '#casesToVars' }
      { include: '#catpcaCommand' }
      { include: '#catregCommand' }
      { include: '#ccfCommand' }
      { include: '#clusterCommand' }
      { include: '#codeBook' }
      { include: '#compareDatasets' }
      { include: '#conjointCommand' }
      { include: '#correlationsCommand' }
      { include: '#correspondenceCommand' }
      { include: '#coxregCommand' }
      { include: '#createCommand' }
    ]
  }

  # Meta groups for command formatting:
  metaCommandFormatting: {
    comment: 'Everything that is formated in a command block, except the command word itself, subcommands, and command/subcom-specific keywords.'
    patterns: [
      { include: '#metaCommandFriendlyComments' }
      { include: '#metaQuoteStrings' }
      { include: '#metaConditionals' }
      { include: '#metaOperators' }
      { include: '#metaConstants' }
      { include: '#metaPunctuation' }
      { include: '#commandBodyText' }
    ]
  }

  # Comments
  multilineCommentAsterisk: {
    comment: 'Identify multi-line comments beginning with an asterisk and ending with a period'
    name: 'comment.block.asterisk.spss'
    begin: '(^\\*)'
    beginCaptures:
      1: name: 'punctuation.definition.comment.spss'
    end: '(\\.\\s*$)'
    endCaptures:
      0: name: 'punctuation.definition.comment.spss'
  }
  multilineCommentCommand: {
    name: 'comment.block.comment.spss'
    begin: '^(?i:COMMENT)'
    beginCaptures:
      1: name: 'punctuation.definition.comment.spss'
    end: '(\\.\\s*$)'
    endCaptures:
      0: name: 'punctuation.definition.comment.spss'
  }
  inlineComment: {
    comment: 'Identify inline comments beginning with `/*` and ending with `*/`'
    name: 'comment.line.spss'
    match: '(\\/\\*)(.*)(\\*\\/)'
  }
  lineComment: {
    comment: 'Identify single-line comments beginning with `/*`'
    name: 'comment.line.spss'
    match: '\\/\\*.*$'
  }

  # Quote strings:
  singleQuoteString: {
    name: 'string.quoted.single.spss'
    begin: '\''
    end: '\''
  }
  doubleQuoteString: {
    name: 'string.quoted.double.spss'
    begin: '"'
    end: '"'
  }

  # Global keywords & operators:
  controlConditionals: {
    name: 'keyword.control.conditionals.spss'
    match: '\\b(?i:(IF|THEN|ELSE|WHILE|FOR|DO|END|REPEAT|BY|WITH|ALL|TO|BREAK))\\b'
  }
  operatorsNumeric: {
    name: 'keyword.operator.numeric.spss'
    match: '\\b(?i:(LOWEST|LO|HIGHEST|HI|THRU|MISSING|SYSMIS))\\b'
  }
  operatorsLogical: {
    name: 'keyword.operator.logical.spss'
    match: '\\b(?i:(AND|OR|NOT))\\b'
  }
  operatorsLogicalSymbolic: {
    name: 'keyword.operator.logical.symbolic.spss'
    match: '\\&|\\|'
  }
  operatorsRelational: {
    name: 'keyword.operator.relational.spss'
    match: '\\b(?i:(EQ|NE|LT|LE|GT|GE))\\b'
  }
  operatorsRelationalSymbolic: {
    name: 'keyword.operator.relational.symbolic.spss'
    match: '=|<>|<|>|<=|>=|~=|Â¬='
  }
  operatorsArithmetic: {
    name: 'keyword.operator.arithmetic.spss'
    match: '\\+|\\-|\\*|/|\\*\\*'
  }

  # Constants:
  plainLanguageConstants: {
    name: 'constant.language.spss'
    match: '\\b(?i:(true|false|null))\\b'
  }

  # Bracket punctuation:
  punctuationForArray: {
    name: 'punctuation.section.array.spss'
    match: '\\[|\\]'
  }
  punctuationForFunction: {
    name: 'punctuation.section.function.spss'
    match: '\\(|\\)'
  }

  # Command body text:
  commandBodyText: {
    comment: 'The command takes up the whole code block, but we only want the command keyword and period to highlight. Also only highlight relevant subcommands and other scopes.'
    name: 'punctuation.command.body.spss'
    match: '(\\$*)(\\#*)(\\@*)\\b([0-9._\\p{L}]+)\\b'
  }

  # Commands:
  simpleCommands: {
    comment: 'Commands with no subcommands or special keywords.'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADD DOCUMENT|ADD VALUE LABELS|CACHE|CD|CLEAR TIME PROGRAM
      |CLEAR TRANSFORMATIONS|COMPUTE|COUNT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  twoStageLeastSquares: {
    comment: '2SLS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(2SLS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to 2SLS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(EQUATION|INSTRUMENTS|ENDOGENOUS))\\b'
      }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomSave' }
      { include: '#subcomPrint' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for 2SLS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PRED|RESSID|COV))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  autocorrelationFunction: {
    comment: 'ACF Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ACF))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ACF.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SERROR|PACF))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomSeasonal' }
      { include: '#subcomMXAuto' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for ACF.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(IND|MA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  addFiles: {
    comment: 'ADD FILES Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADD FILES))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomFile' }
      { include: '#subcomRename' }
      { include: '#subcomDrop' }
      { include: '#subcomKeep' }
      { include: '#subcomIn' }
      { include: '#subcomFirst' }
      { include: '#subcomLast' }
      { include: '#subcomMap' }
      {
        comment: 'Valid keywords for ADD FILES.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  automatedDataPreparation: {
    comment: 'ADP Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ADP))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ADP.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PREPDATETIME|ADJUSTLEVEL|OUTLIERHANDLING|REPLACEMISSING|REORDERNOMINAL))\\b'
      }
      { include: '#subcomFields' }
      { include: '#subcomScreening' }
      { include: '#subcomRescale' }
      { include: '#subcomTransform' }
      { include: '#subcomCriteria' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for ADP.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(TARGET|INPUT|ANALYSISWEIGHT|(DATE|TIME)DURATION
          |EXTRACT(YEAR|MONTH|DAY|HOUR|MINUTE|SECOND)|SUFFIX|PCTMISSING|(UNIQUE|SINGLE)CAT
          |MAXVALORDINAL|MINVALCONTINUOUS|CUTOFF|REPLACEWITH|MERGESUPERVISED|MERGEUNSUPERVISED
          |BINNING|SELECTION|CONSTRUCTION))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aggregateCommand: {
    comment: 'AGGREGATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AGGREGATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AGGREGATE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(DOCUMENT|PRESORTED))\\b'
      }
      { include: '#subcomOutfile' }
      { include: '#subcomBreak' }
      { include: '#subcomMissing' }
      { include: '#subcomSum' }
      { include: '#subcomMean' }
      { include: '#subcomMedian' }
      { include: '#subcomStandardDeviation' }
      { include: '#subcomMax' }
      { include: '#subcomMin' }
      { include: '#subcomPGT' }
      { include: '#subcomPLT' }
      { include: '#subcomPIN' }
      { include: '#subcomPOUT' }
      { include: '#subcomFGT' }
      { include: '#subcomFLT' }
      { include: '#subcomFIN' }
      { include: '#subcomFOUT' }
      { include: '#subcomN' }
      { include: '#subcomNU' }
      { include: '#subcomNMiss' }
      { include: '#subcomNUMiss' }
      { include: '#subcomFirst' }
      { include: '#subcomLast' }
      {
        comment: 'Valid keywords for AGGREGATE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(MODE|OVERWRITE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aimCommand: {
    comment: 'AIM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AIM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCategorical' }
      { include: '#subcomContinuous' }
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for AIM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(ADJUST|CI|HIDENOTSIG|SHOWREFLINE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  alscalCommand: {
    comment: 'ALSCAL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ALSCAL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ALSCAL.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(LEVEL))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomInput' }
      { include: '#subcomShape' }
      { include: '#subcomCondition' }
      { include: '#subcomFile' }
      { include: '#subcomModel' }
      { include: '#subcomCriteria' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomOutfile' }
      { include: '#subcomMatrix' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  alterType: {
    comment: 'ALTER TYPE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ALTER TYPE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomPrint' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  anacorCommand: {
    comment: 'ANACOR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ANACOR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ANACOR.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(VARIANCES))\\b'
      }
      { include: '#subcomTable' }
      { include: '#subcomDimension' }
      { include: '#subcomNormalization' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMatrix' }
      {
        comment: 'Valid keywords for ANACOR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(OUT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  analysisOfVariance: {
    comment: 'ANOVA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ANOVA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ANOVA.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(COVARIATES|MAXORDERS))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomMethod' }
      { include: '#subcomStatistics' }
      { include: '#subcomMissing' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  applyDictionary: {
    comment: 'APPLY DICTIONARY Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(APPLY DICTIONARY))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to APPLY DICTIONARY.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(NEWVARS))\\b'
      }
      { include: '#subcomFrom' }
      { include: '#subcomSource' }
      { include: '#subcomTarget' }
      { include: '#subcomFileInfo' }
      { include: '#subcomVarInfo' }
      {
        comment: 'Valid keywords for ANACOR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD|ATTRIBUTES|ALIGNMENT|DOCUMENTS|FILELABEL|FORMATS|LEVEL
          |MRSETS|VARSETS|WEIGHT|ALL|MISSING|ROLE|VALLABELS|WIDTH))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  aregCommand: {
    comment: 'AREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(RHO|MXITER))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomMethod' }
      { include: '#subcomConstant' }
      { include: '#subcomNoConstant' }
      { include: '#subcomApply' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  arimaCommand: {
    comment: 'ARIMA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(ARIMA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to ARIMA.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(CINPCT|FORECAST))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomModel' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for ARIMA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(P|D|Q|SP|SD|SQ|AR|MA|SAR|SMA|REG|CON|CONSTANT|NOCONSTANT
          |NOLOG|LG10|LN|MXITER|PAREPS|SSQPCT|MXLAMB|SPECIFICATIONS|INITIAL|FIT|EXACT
          |CLS|AUTOINIT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  autoRecode: {
    comment: 'AUTORECODE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(AUTORECODE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to AUTORECODE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(BLANK|GROUP|SAVE TEMPLATE|APPLY TEMPLATE|DESCENDING))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomInto' }
      { include: '#subcomPrint' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesANOVA: {
    comment: 'BAYES ANOVA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES ANOVA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES ANOVA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|REGWGT|VARIABLES|ANALYSIS|COMPUTATION
          |TYPE|SHAPEPARAM|SCALEPARAM|MEANVECTOR|VMATRIX|MEANS|ERRORVAR))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesCorrelation: {
    comment: 'BAYES CORRELATION Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES CORRELATION))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      {
        comment: 'Valid keywords for BAYES CORRELATION.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|TOL|MAXITER|MCSAMPLES|POSTSAMPLES|VARIABLES
          |ANALYSIS|CVALUE|MAXPLOTS|TYPE|NULLVALUE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesIndependent: {
    comment: 'BAYES INDEPENDENT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES INDEPENDENT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES INDEPENDENT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|VARIABLES|GROUP|SELECT|DATAVAR|ANALYSIS
          |COMPUTATION|EQUALDATAVAR|VARDIST|MEANDIST))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesLogLinear: {
    comment: 'BAYES LOGLINEAR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES LOGLINEAR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomTable' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrint' }
      {
        comment: 'Valid keywords for BAYES LOGLINEAR.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|TOL|MAXITER|POSTSAMPLES|ORDER|ANALYSIS|MODEL
          |FIXMARGIN|FIXMARGINS|FIX_MARGINS|PRIORTYPE|PRIOR_TYPE|SHAPEPARAMS|SCALEPARAM
          |LAMBDAS|SUPPRESSTABLE|SUPPRESS_TABLE|CELLS|STATISTICS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesOneSample: {
    comment: 'BAYES ONESAMPLE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES ONESAMPLE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomData' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES ONESAMPLE.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SCOPE|CILEVEL|DISTRIBUTION|VARIABLES|ANALYSIS|SUCCESS
          |NULLPRIORPARAM|ALTERPRIORPARAM|VARDIST|PREDIST|TYPE|METHOD|SEED|TOL|MAXITER
          |MCSAMPLES|VARIANCE|NULLVALUE|ALTERGVALUE|PRECDIST|MEANDIST|KAPPA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRegression: {
    comment: 'BAYES REGRESSION Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES REGRESSION))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BAYES REGRESSION.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PREDICT|FTEST))\\b'
      }
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPrior' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES REGRESSION.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|TOL|MAXITER|REGWGT|FACTORS|COVARIATES|ANALYSIS
          |COMPUTATION|COMPARE|TYPE|SHAPEPARAM|SCALEPARAM|MEANVECTOR|VMATRIX|REGRESSORS
          |PARAMETER|MAX_CATEGORY|INTERCEPT|ERRORVAR|BAYESPRED|LABEL|VARIABLES|TESTVALUES))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRelated: {
    comment: 'BAYES RELATED Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES RELATED))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BAYES RELATED.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(PAIR))\\b'
      }
      { include: '#subcomMissing' }
      { include: '#subcomCriteria' }
      { include: '#subcomInference' }
      { include: '#subcomPrior' }
      {
        comment: 'Valid keywords for BAYES RELATED.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SCOPE|CILEVEL|METHOD|SEED|TOL|MAXITER|MCSAMPLES|ANALYSIS
          |VARIABLES|VARIANCE|NULLVALUE|ALTERGVALUE|VARDIST|PRECDIST|MEANDIST|KAPPA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bayesRepeated: {
    comment: 'BAYES REPEATED Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BAYES REPEATED))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomCriteria' }
      { include: '#subcomDesign' }
      { include: '#subcomInference' }
      { include: '#subcomESTBF' }
      { include: '#subcomPlot' }
      {
        comment: 'Valid keywords for BAYES REPEATED.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(CILEVEL|SEED|MCSAMPLES|REGWGT|ANALYSIS|COMPUTATION|MEANS))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginData: {
    comment: 'BEGIN DATA-END DATA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN DATA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END DATA))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginExpr: {
    comment: 'BEGIN EXPR-END EXPR Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN EXPR))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END EXPR))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  simprepBegin: {
    comment: 'SIMPREP BEGIN-SIMPREP END Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(SIMPREP BEGIN))\\b'
    beginCaptures:
      1: name: 'invalid.deprecated.command.spss'
    end: '\\b(?i:(SIMPREP END))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'invalid.deprecated.command.end.spss'
    patterns: [
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginGPL: {
    comment: 'BEGIN GPL-END GPL Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN GPL))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END GPL))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for BEGIN GPL-END GPL.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SOURCE|DATA|SCALE|GUIDE|ELEMENT|COORD|PAGE|GRAPH|COMMENT|TRANS))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  beginProgram: {
    comment: 'BEGIN PROGRAM-END PROGRAM Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BEGIN PROGRAM))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '\\b(?i:(END PROGRAM))\\b((\\.\\s*$)*|(^\\s*$)*)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'Valid keywords for BEGIN PROGRAM-END PROGRAM.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PYTHON3))\\b'
      }
      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  bootStrap: {
    comment: 'BOOTSTRAP Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(BOOTSTRAP))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to BOOTSTRAP.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SAMPLING))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomCriteria' }
      { include: '#subcomMissing' }
      {
        comment: 'Valid keywords for BOOTSTRAP.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(SIMPLE|STRATIFIED|RESIDUAL|WILD|TARGET|INPUT|CILEVEL|CITYPE
          |NSAMPLES|USERMISSING))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  casePlot: {
    comment: 'CASEPLOT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CASEPLOT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomID' }
      { include: '#subcomFormat' }
      { include: '#subcomMark' }
      { include: '#subcomSplit' }
      { include: '#subcomApply' }
      {
        comment: 'Valid keywords for CASEPLOT.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(REFERENCE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  casesToVars: {
    comment: 'CASESTOVARS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CASESTOVARS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CASESTOVARS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(VIND|AUTOFIX|SEPARATOR|GROUPBY))\\b'
      }
      { include: '#subcomID' }
      { include: '#subcomIndex' }
      { include: '#subcomCount' }
      { include: '#subcomFixed' }
      { include: '#subcomRename' }
      { include: '#subcomDrop' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  catpcaCommand: {
    comment: 'CATPCA Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CATPCA))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomAnalysis' }
      { include: '#subcomDiscretization' }
      { include: '#subcomMissing' }
      { include: '#subcomSupplementary' }
      { include: '#subcomConfiguration' }
      { include: '#subcomDimension' }
      { include: '#subcomNormalization' }
      { include: '#subcomMaxIter' }
      { include: '#subcomCritIter' }
      { include: '#subcomRotation' }
      { include: '#subcomResample' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CATPCA.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(WEIGHT|LEVEL|BOOTSTRAP|OBJECT|CATEGORY|LOADING|TRANS|RESID
          |BIPLOT|TRIPLOT|JOINTCAT|PROJCENTR|VAF|LDELLAREA|OBELLAREA|CTELLAREA|NELLPNT
          |NONE|NDIM|CENTR|DISCRDATA|TRDATA|APPROX|ELLCOORD))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  catregCommand: {
    comment: 'CATREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CATREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CATREG.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(REGULARIZATION))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomAnalysis' }
      { include: '#subcomDiscretization' }
      { include: '#subcomMissing' }
      { include: '#subcomSupplementary' }
      { include: '#subcomInitial' }
      { include: '#subcomMaxIter' }
      { include: '#subcomCritIter' }
      { include: '#subcomResample' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomSave' }
      { include: '#subcomOutfile' }
      {
        comment: 'Valid keywords for CATREG.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(LEVEL|OBJECT|NONE|RIDGE|LASSO|ENET|CROSSVAL|BOOTSTRAP
          |TRANS|RESID|REGU|DISCRDATA|TRDATA))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  ccfCommand: {
    comment: 'CCF Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CCF))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CCF.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(MXCROSS))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomPeriod' }
      { include: '#subcomNaturalLogarithm' }
      { include: '#subcomNoLog' }
      { include: '#subcomSeasonal' }
      { include: '#subcomApply' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  clusterCommand: {
    comment: 'CLUSTER Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CLUSTER))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomMeasure' }
      { include: '#subcomMethod' }
      { include: '#subcomSave' }
      { include: '#subcomID' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomMissing' }
      { include: '#subcomMatrix' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  codeBook: {
    comment: 'CODEBOOK Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CODEBOOK))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVarInfo' }
      { include: '#subcomFileInfo' }
      { include: '#subcomStatistics' }
      { include: '#subcomOptions' }
      {
        comment: 'Valid keywords for CODEBOOK.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(MAXCATS|VARORDER|SORT))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  compareDatasets: {
    comment: 'COMPARE DATASETS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(COMPARE DATASETS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to COMPARE DATASETS.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(COMPDATASET|CASEID))\\b'
      }
      { include: '#subcomVariables' }
      { include: '#subcomSave' }
      { include: '#subcomOutput' }
      {
        comment: 'Valid keywords for COMPARE DATASETS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(PASSWORD|FLAGMISMATCHES|MATCHDATASET|MISMATCHDATASET
          |ENCRYPTEDPW|VARPROPERTIES|CASETABLE))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  conjointCommand: {
    comment: 'CONJOINT Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CONJOINT))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CONJOINT.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(SEQUENCE|RANK|SCORE|SUBJECT|UTILITY))\\b'
      }
      { include: '#subcomPlan' }
      { include: '#subcomData' }
      { include: '#subcomFactors' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  correlationsCommand: {
    comment: 'CORRELATIONS Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CORRELATIONS))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomPrint' }
      { include: '#subcomStatistics' }
      { include: '#subcomMissing' }
      { include: '#subcomMatrix' }
      { include: '#subcomCI' }
      {
        comment: 'Valid keywords for CORRELATIONS.'
        name: 'keyword.other.spss'
        match: '(/?)\\b(?i:(METHOD|BIAS|CILEVEL))\\b'
      }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  correspondenceCommand: {
    comment: 'CORRESPONDENCE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CORRESPONDENCE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CORRESPONDENCE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(EQUAL))\\b'
      }
      { include: '#subcomTable' }
      { include: '#subcomDimension' }
      { include: '#subcomSupplementary' }
      { include: '#subcomMeasure' }
      { include: '#subcomStandardize' }
      { include: '#subcomNormalization' }
      { include: '#subcomPrint' }
      { include: '#subcomPlot' }
      { include: '#subcomOutfile' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  coxregCommand: {
    comment: 'COXREG Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(COXREG))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      { include: '#subcomVariables' }
      { include: '#subcomStatus' }
      { include: '#subcomStrata' }
      { include: '#subcomCategorical' }
      { include: '#subcomContrast' }
      { include: '#subcomMethod' }
      { include: '#subcomMissing' }
      { include: '#subcomPrint' }
      { include: '#subcomCriteria' }
      { include: '#subcomPlot' }
      { include: '#subcomPattern' }
      { include: '#subcomOutfile' }
      { include: '#subcomSave' }
      { include: '#subcomExternal' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  createCommand: {
    comment: 'CREATE Command'
    name: 'meta.class.command.spss'
    begin: '\\b(?i:(CREATE))\\b'
    beginCaptures:
      1: name: 'support.class.command.spss'
    end: '(\\.\\s*$)|(^\\s*$)'
    endCaptures:
      0: name: 'support.class.command.end.spss'
    patterns: [
      {
        comment: 'These subcommands are exclusive to CREATE.'
        name: 'support.function.subcommand.spss'
        match: '(/?)\\b(?i:(CSUM|FFT|IFFT|LAG|LEAD|PMA|RMED|T4253H))\\b'
      }
      { include: '#subcomDiff' }
      { include: '#subcomSDiff' }
      { include: '#subcomMA' }

      # Global command includes:
      { include: '#metaCommandFormatting' }
    ]
  }

  # Common subcommands:
  subcomAnalysis: {
    comment: 'Specify variables used in computations, scaling level, weights.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ANALYSIS))\\b'
  }
  subcomApply: {
    comment: 'Use a previously defined model.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(APPLY))\\b'
  }
  subcomBreak: {
    comment: 'Lists optional grouping variables.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(BREAK))\\b'
  }
  subcomCategorical: {
    comment: 'Treat variables as categorical.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CATEGORICAL))\\b'
  }
  subcomCI: {
    comment: 'Controls estimation of confidence intervals.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CI))\\b'
  }
  subcomCondition: {
    comment: 'Specify which numbers are comparable.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONDITION))\\b'
  }
  subcomConfiguration: {
    comment: 'Read data from file containing coodinates of a configuration.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONFIGURATION))\\b'
  }
  subcomConstant: {
    comment: 'Subcommand to specify a constant term in a regression equation.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONSTANT))\\b'
  }
  subcomContinuous: {
    comment: 'Treat variables as continuous.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONTINUOUS))\\b'
  }
  subcomContrast: {
    comment: 'Specifies type of contrast for categorical covariates.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CONTRAST))\\b'
  }
  subcomCount: {
    comment: 'Create new variable containing rows in original data used to generate row in new data.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(COUNT))\\b'
  }
  subcomCriteria: {
    comment: 'Subcommand has various purposes depending on the command context.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CRITERIA))\\b'
  }
  subcomCritIter: {
    comment: 'Specifies convergence criterion value.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(CRITITER))\\b'
  }
  subcomData: {
    comment: 'Specifies recode data and set parameters for estimation of Bayes factors.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DATA))\\b'
  }
  subcomDesign: {
    comment: 'Specifies the model design.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DESIGN))\\b'
  }
  subcomDiff: {
    comment: 'Specifies degree of differencing.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIFF))\\b'
  }
  subcomDimension: {
    comment: 'Specifies number of dimensions.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DIMENSION))\\b'
  }
  subcomDiscretization: {
    comment: 'Specifies fractional-value variables to discretize.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DISCRETIZATION))\\b'
  }
  subcomDrop: {
    comment: 'Specifies variables to exclude.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(DROP))\\b'
  }
  subcomESTBF: {
    comment: 'Specifies approached used to estimate Bayes factors.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ESTBF))\\b'
  }
  subcomExternal: {
    comment: 'Specifies that data should be held in external scratch file.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(EXTERNAL))\\b'
  }
  subcomFactors: {
    comment: 'Specifies way each factor is expected to be related.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FACTORS))\\b'
  }
  subcomFGT: {
    comment: 'Fraction of cases greater than value.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FGT))\\b'
  }
  subcomFields: {
    comment: 'Specifies target, inputs, weights.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIELDS))\\b'
  }
  subcomFile: {
    comment: 'Identifies or reads a file.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FILE))\\b'
  }
  subcomFileInfo: {
    comment: 'Applies file definition attributes from source dataset to target dataset.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FILEINFO))\\b'
  }
  subcomFIN: {
    comment: 'Fraction of cases between two values.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIN))\\b'
  }
  subcomFirst: {
    comment: 'Creates logical variable to flag first case, or returns first nonmissing value.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIRST))\\b'
  }
  subcomFixed: {
    comment: 'Names variables to be copied from original data to new data file.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FIXED))\\b'
  }
  subcomFLT: {
    comment: 'Fraction of cases less than value.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FLT))\\b'
  }
  subcomFormat: {
    comment: 'Controls plot format.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FORMAT))\\b'
  }
  subcomFOUT: {
    comment: 'Fraction of cases not between two values.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FOUT))\\b'
  }
  subcomFrom: {
    comment: 'Specifies a datafile or dataset with dictionary information.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(FROM))\\b'
  }
  subcomID: {
    comment: 'Names variable whose values will be used.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ID))\\b'
  }
  subcomIn: {
    comment: 'Creates a new variable indicating case source.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(IN))\\b'
  }
  subcomIndex: {
    comment: 'Names variables in original data used to create new columns.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INDEX))\\b'
  }
  subcomInference: {
    comment: 'Controls which Bayesian analysis method is used to make statistical inference.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INFERENCE))\\b'
  }
  subcomInitial: {
    comment: 'Specify method to compute initial value or configuration.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INITIAL))\\b'
  }
  subcomInput: {
    comment: 'Specify number of rows in matrix.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INPUT))\\b'
  }
  subcomInto: {
    comment: 'Provide name of target variables that store new values.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(INTO))\\b'
  }
  subcomKeep: {
    comment: 'Specifies variables to retain.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(KEEP))\\b'
  }
  subcomLast: {
    comment: 'Creates logical variable to flag last case, or returns last nonmissing value.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LAST))\\b'
  }
  subcomMA: {
    comment: 'Produces a new series based on centered moving averages of existing series.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MA))\\b'
  }
  subcomMap: {
    comment: 'Produces list of variables included in new dataset and their source.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAP))\\b'
  }
  subcomMark: {
    comment: 'Indicates the onset of an intervention variable.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MARK))\\b'
  }
  subcomMatrix: {
    comment: 'Reads matrix data file.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MATRIX))\\b'
  }
  subcomMax: {
    comment: 'Maximum value across cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAX))\\b'
  }
  subcomMaxIter: {
    comment: 'Maximum number of iterations a procedure can go through.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MAXITER))\\b'
  }
  subcomMean: {
    comment: 'Mean across cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEAN))\\b'
  }
  subcomMeasure: {
    comment: 'Specifies distance or similarity measure used to cluster cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEASURE))\\b'
  }
  subcomMedian: {
    comment: 'Median across cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MEDIAN))\\b'
  }
  subcomMethod: {
    comment: 'Method for decomposing sums of squares.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(METHOD))\\b'
  }
  subcomMin: {
    comment: 'Minimum value across cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MIN))\\b'
  }
  subcomMissing: {
    comment: 'Specify how missing values are treated.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MISSING))\\b'
  }
  subcomModel: {
    comment: 'Defines scaling model.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MODEL))\\b'
  }
  subcomMXAuto: {
    comment: 'Specify maximum number of lags for a series.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(MXAUTO))\\b'
  }
  subcomN: {
    comment: 'Weighted number of cases in break group.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(N))\\b'
  }
  subcomNU: {
    comment: 'Unweighted number of cases in break group.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NU))\\b'
  }
  subcomNaturalLogarithm: {
    comment: 'Transforms data using natural logarithm.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(LN))\\b'
  }
  subcomNMiss: {
    comment: 'Weighted number of missing cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NMISS))\\b'
  }
  subcomNUMiss: {
    comment: 'Unweighted number of missing cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NUMISS))\\b'
  }
  subcomNoConstant: {
    comment: 'Subcommand to eliminate a constant term in a regression equation.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOCONSTANT))\\b'
  }
  subcomNoLog: {
    comment: 'Indicate that data should not be log transformed.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NOLOG))\\b'
  }
  subcomNormalization: {
    comment: 'Specify method for normalizing row and column scores.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(NORMALIZATION))\\b'
  }
  subcomOptions: {
    comment: 'Suppress display of certain variable information and control display order.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OPTIONS))\\b'
  }
  subcomOutfile: {
    comment: 'Saves file of rules, coordinates, weights, and so on used in data preparation.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OUTFILE))\\b'
  }
  subcomOutput: {
    comment: 'Produce a table that compares dictionary information.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(OUTPUT))\\b'
  }
  subcomPattern: {
    comment: 'Specifies pattern of covariate values.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PATTERN))\\b'
  }
  subcomPeriod: {
    comment: 'Indicates length of seasonal period.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PERIOD))\\b'
  }
  subcomPGT: {
    comment: 'Percentage of cases greater than value.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PGT))\\b'
  }
  subcomPIN: {
    comment: 'Percentage of cases between two values.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PIN))\\b'
  }
  subcomPlan: {
    comment: 'Identifies file containing full-concept profiles.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLAN))\\b'
  }
  subcomPLT: {
    comment: 'Percentage of cases less than value.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLT))\\b'
  }
  subcomPlot: {
    comment: 'Specifies a graph to produce.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PLOT))\\b'
  }
  subcomPOUT: {
    comment: 'Percentage of cases not between two values.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(POUT))\\b'
  }
  subcomPrint: {
    comment: 'Prints an additional output not available by default.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PRINT))\\b'
  }
  subcomPrior: {
    comment: 'Specifies prior distribution settings.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(PRIOR))\\b'
  }
  subcomRename: {
    comment: 'Renames variables before they are processed by command.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RENAME))\\b'
  }
  subcomResample: {
    comment: 'Specifies resampling method.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RESAMPLE))\\b'
  }
  subcomRescale: {
    comment: 'Rescale continuous fields.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(RESCALE))\\b'
  }
  subcomRotation: {
    comment: 'Specifies rotation method.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(ROTATION))\\b'
  }
  subcomSave: {
    comment: 'Saves a value (specified by a keyword).'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SAVE))\\b'
  }
  subcomScreening: {
    comment: 'Specifies settings for excluding unsuitable fields.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SCREENING))\\b'
  }
  subcomSDiff: {
    comment: 'Specifies degree of seasonal differencing.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SDIFF))\\b'
  }
  subcomSeasonal: {
    comment: 'Focus on seasonal component by plotting autocorrelations at periodic lags.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SEASONAL))\\b'
  }
  subcomShape: {
    comment: 'Specify structure of matrix.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SHAPE))\\b'
  }
  subcomSource: {
    comment: 'Specify variables in a source file.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SOURCE))\\b'
  }
  subcomSplit: {
    comment: 'Specifies how to plot data divided into subgroups.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SPLIT))\\b'
  }
  subcomStandardDeviation: {
    comment: 'Standard deviation across cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SD))\\b'
  }
  subcomStandardize: {
    comment: 'Specifies method of standardization.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STANDARDIZE))\\b'
  }
  subcomStatistics: {
    comment: 'Requests additional statistics.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STATISTICS))\\b'
  }
  subcomStatus: {
    comment: 'Lists status variable and code for occurrence of event.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STATUS))\\b'
  }
  subcomStrata: {
    comment: 'Identifies stratification variable.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(STRATA))\\b'
  }
  subcomSum: {
    comment: 'Sum across cases.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUM))\\b'
  }
  subcomSupplementary: {
    comment: 'Specifies objects or variables to treat as supplementary.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(SUPPLEMENTARY))\\b'
  }
  subcomTable: {
    comment: 'Specifies row and column variables.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TABLE))\\b'
  }
  subcomTarget: {
    comment: 'Specifies variables in active dataset.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TARGET))\\b'
  }
  subcomTransform: {
    comment: 'Merge similar categories.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(TRANSFORM))\\b'
  }
  subcomVariables: {
    comment: 'Specifies variables in analysis.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VARIABLES))\\b'
  }
  subcomVarInfo: {
    comment: 'Applies variable definition attributes from source dataset to active dataset.'
    name: 'support.function.subcommand.spss'
    match: '(/?)\\b(?i:(VARINFO))\\b'
  }

  # Add highlighting for other system variables. We have $SYSMIS here but there are others
  # Use scope invalid.deprecated for deprecated commands
  # Subcommand keywords in commands is inconsistent right now. Need to revise this later.
